{"result":{"catalog_client_script":{"GlideServletRequest":{"!doc":"ServiceNow processors are equivalent to Java servlets. Processors provide a customizable URL endpoint that can execute arbitrary server-side Javascript code and produce output such as TEXT, JSON, or HTML. The GlideServletRequest API is used in processor scripts to access the HttpServletRequest object. The GlideServletRequest object provides a subset of the HttpServletRequest APIs. The methods are called using the global variable g_request. A useful global variable, g_target, is available in processor scripts. It contains the table name extracted from the URL. The URL to a processor has the format: https://<instance name.servicenow.com>/<path endpoint>.do?<parameter endpoint>=<value> where the path endpoint and parameter endpoint are defined on the processor form","!type":"fn()","prototype":{"getHeaders":{"!doc":"Returns an array of headers as a string","!type":"fn(name: string) -> [string]"},"getHeaderNames":{"!doc":"Returns an array of header names as a string","!type":"fn() -> [string]"},"getQueryString":{"!doc":"Returns the query string from the request","!type":"fn() -> string"},"getContentType":{"!doc":"Returns the content type","!type":"fn() -> string"},"getParameterNames":{"!doc":"Returns an array of parameter names as a string","!type":"fn() -> [string]"},"getHeader":{"!doc":"Returns the header","!type":"fn(name: string) -> string"},"getParameter":{"!doc":"Returns an object","!type":"fn(name: string) -> ?"}}},"XMLNode":{"!doc":"The scoped XMLNode API allows you to query values from XML nodes. XMLNodes are extracted from XMLDocument2 objects, which contain XML strings","!type":"fn()","prototype":{"getNodeValue":{"!doc":"Gets the node's value","!type":"fn() -> string"},"appendChild":{"!doc":"","!type":"fn(newChild: +XMLNode)"},"setAttribute":{"!doc":"","!type":"fn(attribute: string, value: string)"},"getChildNodeIterator":{"!doc":"Gets the node's XMLNodeIterator object","!type":"fn() -> +XMLNodeIterator"},"getAttribute":{"!doc":"Gets the value of the specified attribute","!type":"fn(attribute: string) -> string"},"hasAttribute":{"!doc":"Determines if the node has the specified attribute","!type":"fn(attribute: string) -> bool"},"getFirstChild":{"!doc":"Gets the node's first child node","!type":"fn() -> +XMLNode"},"toString":{"!doc":"Gets the node's string value","!type":"fn() -> string"},"getTextContent":{"!doc":"Gets the node's text content","!type":"fn() -> string"},"getNodeName":{"!doc":"Gets the node's name","!type":"fn() -> string"},"getLastChild":{"!doc":"Gets the node's last child node","!type":"fn() -> +XMLNode"}}},"GlideScopedEvaluator":{"!doc":"The API allows you to evaluate scripts from a GlideRecord field","!type":"fn()","prototype":{"evaluateScript":{"!doc":"Evaluates a script from a GlideRecord field. variables parameter is optional","!type":"fn(gr: +GlideRecord, scriptField: string, variables: ?) -> ?"},"putVariable":{"!doc":"Puts a variable into the GlideScopedEvaluator object","!type":"fn(name: string, value: ?)"},"getVariable":{"!doc":"Gets a variable from a GlideScopedEvaluator object","!type":"fn(name: string) -> ?"}}},"GlideTableHierarchy":{"!doc":"The Scoped GlideTableHierarchy API provides methods for handling information about table relationships","!type":"fn()","prototype":{"hasExtensions":{"!doc":"Returns true of this class has been extended","!type":"fn() -> bool"},"getName":{"!doc":"Returns the table's name","!type":"fn() -> string"},"isSoloClass":{"!doc":"Returns true if this table is not in a hierarchy","!type":"fn() -> bool"},"getTables":{"!doc":"Returns a list of the table names in the hierarchy","!type":"fn() -> []"},"getAllExtensions":{"!doc":"Returns a list of all tables that extend the current table and includes the current table","!type":"fn() -> []"},"isBaseClass":{"!doc":"Returns true if this is a base class","!type":"fn() -> bool"},"getTableExtensions":{"!doc":"Returns a list of all tables that extend the current table","!type":"fn() -> []"},"getBase":{"!doc":"Returns the parent class","!type":"fn() -> string"},"getRoot":{"!doc":"Returns the top level class in the hierarchy","!type":"fn() -> string"},"getHierarchy":{"!doc":"Returns a list of all classes in the hierarchy of the given table","!type":"fn() -> []"}}},"GlidePluginManager":{"!doc":"Scoped API for PluginManager","!type":"fn()","prototype":{"isActive":{"!doc":"Determine if a plugin is activated","!type":"fn(pluginID: string) -> bool"}}},"sn_auth":{"":{"prototype":{}},"GlideOAuthClient":{"!doc":"The OAuth client API provides methods to request and revoke OAuth tokens","!type":"fn()","prototype":{"revokeToken":{"!doc":"Revokes the access or refresh token for the client, with the request and optional header parameters set into a GlideOAuthClientRequest object","!type":"fn(clientName: string, accessToken: string, refreshToken: string, request: GlideOAuthClientRequest) -> +sn_auth.GlideOAuthClientResponse"},"requestTokenByRequest":{"!doc":"Retrieves the token for the client, with the request and optional header parameters set into a GlideOAuthClientRequest object","!type":"fn(clientName: string, request: GlideOAuthClientRequest) -> +sn_auth.GlideOAuthClientResponse"},"requestToken":{"!doc":"Retrieves the token for the client, with the request parameters encoded in JSON format","!type":"fn(clientName: string, jsonString: string) -> +sn_auth.GlideOAuthClientResponse"}}},"!doc":"Authentication API","GlideOAuthClientRequest":{"!doc":"Use these methods for handling client requests","!type":"fn()","prototype":{"getRefreshToken":{"!doc":"Retrieves the refresh token","!type":"fn() -> string"},"setPassword":{"!doc":"Sets the password with the string you provide","!type":"fn(password: string)"},"getHeaders":{"!doc":"Retrieves the HTTP headers","!type":"fn() -> ?"},"setHeader":{"!doc":"Sets the HTTP headers for the nave:value pair that you provide","!type":"fn(name: string, value: string)"},"getHeader":{"!doc":"Retrieves the HTTP headers for the string you provide","!type":"fn(name: string)"},"getPassword":{"!doc":"Retrieves the password","!type":"fn() -> string"},"setUserName":{"!doc":"Sets the user name with the string you provide","!type":"fn(userName: string)"},"setParameter":{"!doc":"Sets the parameters for the name:value pair of strings you provide","!type":"fn(name: string, value: string)"},"getGrantType":{"!doc":"Retrieves the grant type","!type":"fn()"},"setGrantType":{"!doc":"Sets the grant type with the string you provide","!type":"fn()"},"getUserName":{"!doc":"Retrieves the user name","!type":"fn() -> string"},"setScope":{"!doc":"Sets the scope with the string you provide","!type":"fn(scope: string)"},"setRefreshToken":{"!doc":"Sets the refresh token with the string you provide","!type":"fn(refreshToken: string)"},"getScope":{"!doc":"Retrieves the scope","!type":"fn() -> string"},"getParameter":{"!doc":"Retrieves the parameter for the parameter name you provide","!type":"fn(name: string)"}}},"GlideOAuthClientResponse":{"!doc":"","!type":"fn()","prototype":{"getResponseParameters":{"!doc":"Retrieves the response content from an external OAuth provider. The response is in a name:value pair","!type":"fn() -> ?"},"getBody":{"!doc":"Retrieves all of the response information, including instance information","!type":"fn() -> string"},"getToken":{"!doc":"Retrieves the refresh token","!type":"fn() -> +sn_auth.GlideOAuthToken"},"getResponseCode":{"!doc":"Retrieves the HTTP response code from the external OAuth provider","!type":"fn() -> string"},"getContentType":{"!doc":"Retrieves the HTTP response content header from an external OAuth provider","!type":"fn() -> string"},"getErrorMessage":{"!doc":"Retrieves the error message if authentication is not successful","!type":"fn() -> string"}}},"GlideOAuthToken":{"!doc":"Use these methods for retrieving the access token and information about the access token","!type":"fn()","prototype":{"getRefreshToken":{"!doc":"Retrieves the refresh token","!type":"fn() -> number"},"getRefreshTokenSysID":{"!doc":"Retrieves the sys_id of the refresh token","!type":"fn() -> string"},"getExpiresIn":{"!doc":"Retrieves the lifespan of the access token in seconds","!type":"fn() -> number"},"getAccessTokenSysID":{"!doc":"Retrieves the sys_id of the token ID","!type":"fn() -> string"},"getScope":{"!doc":"Retrieves the scope, which is the amount of access granted by the access token","!type":"fn() -> string"},"getAccessToken":{"!doc":"Retrieves the access token","!type":"fn() -> string"}}}},"GlideRecord":{"!doc":"Scoped GlideRecord is used for database operations instead of writing SQL queries. Provides data access APIs to retrieve, update, and delete records from a table","!type":"fn(tableName: string)","prototype":{"getLastErrorMessage":{"!doc":"Retrieves the last error message","!type":"fn() -> string"},"getLabel":{"!doc":"The label of the field as a String","!type":"fn() -> string"},"addJoinQuery":{"!doc":"Adds a filter to return records based on a relationship in a related table","!type":"fn(joinTable: string, primaryField: ?, joinTableField: ?) -> +GlideQueryCondition"},"setCategory":{"!doc":"","!type":"fn(category: string)"},"addActiveQuery":{"!doc":"Adds a filter to return active records","!type":"fn() -> +GlideQueryCondition"},"canDelete":{"!doc":"Determines if the Access Control Rules which include the user's roles permit deleting records in this table","!type":"fn() -> bool"},"setAbortAction":{"!doc":"Sets a flag to indicate if the next database action (insert, update, delete) is to be aborted","!type":"fn(b: bool)"},"getRowCount":{"!doc":"Retrieves the number of rows in the GlideRecord","!type":"fn() -> number"},"addFunction":{"!doc":"Retrieve the specified platform function in addition of the field values","!type":"fn(functionDefinition: string)"},"query":{"!doc":"Runs the query against the table based on the specified filters by addQuery and addEncodedQuery","!type":"fn()"},"getTableName":{"!doc":"Retrieves the table name associated with this GlideRecord","!type":"fn() -> string"},"getCategory":{"!doc":"","!type":"fn() -> string"},"orderByDesc":{"!doc":"Specifies a descending orderBy","!type":"fn(fieldName: string)"},"hasNext":{"!doc":"Determines if there are any more records in the GlideRecord","!type":"fn() -> bool"},"getClassDisplayValue":{"!doc":"","!type":"fn() -> string"},"isNewRecord":{"!doc":"Checks if the current record is a new record that has not yet been inserted into the database","!type":"fn() -> bool"},"getEncodedQuery":{"!doc":"Retrieves the query condition of the current result set as an encoded query string","!type":"fn() -> string"},"updateMultiple":{"!doc":"Updates each GlideRecord in the list with any changes that have been made","!type":"fn()"},"getRecordClassName":{"!doc":"Retrieves the class name for the current record","!type":"fn() -> string"},"autoSysFields":{"!doc":"","!type":"fn(b: bool)"},"getDisplayName":{"!doc":"Retrieves the name of the display field","!type":"fn() -> string"},"addQuery":{"!doc":"Adds a filter to return records by specifying a field and value. You can use an optional 'operator' as a second parameter","!type":"fn(name: string, value: string) -> +GlideQueryCondition"},"setLimit":{"!doc":"Sets the maximum number of records in the GlideRecord to be fetched in the next query","!type":"fn(limit: number)"},"getUniqueValue":{"!doc":"Gets the primary key of the record, which is usually the sys_id unless otherwise specified","!type":"fn() -> string"},"next":{"!doc":"Moves to the next record in the GlideRecord","!type":"fn() -> bool"},"deleteMultiple":{"!doc":"Deletes records that satisfy current query condition","!type":"fn()"},"canRead":{"!doc":"Determines if the Access Control Rules which include the user's roles permit reading records in this table","!type":"fn() -> bool"},"insert":{"!doc":"Insert a new record using the field values that have been set for the current record","!type":"fn() -> string"},"update":{"!doc":"Updates the current GlideRecord with any changes that have been made","!type":"fn(reason: ?) -> string"},"orderBy":{"!doc":"Specifies an orderBy column","!type":"fn(fieldName: string)"},"addNotNullQuery":{"!doc":"Adds a filter to return records where the specified field is not null","!type":"fn(fieldName: string) -> +GlideQueryCondition"},"addNullQuery":{"!doc":"Adds a filter to return records where the specified field is null","!type":"fn(fieldName: string) -> +GlideQueryCondition"},"addEncodedQuery":{"!doc":"Adds an encoded query to the other queries that may have been set","!type":"fn(query: string)"},"getAttribute":{"!doc":"Gets the attributes on the field in question from the dictionary","!type":"fn(attribute: string) -> string"},"get":{"!doc":"Defines a GlideRecord based on the specified expression of name = value","!type":"fn(name: ?, value: ?) -> bool"},"isValidRecord":{"!doc":"Determines if current record is a valid record","!type":"fn() -> bool"},"setNewGuidValue":{"!doc":"Sets sys_id value for the current record","!type":"fn(guid: string)"},"isValid":{"!doc":"Determines whether the table exists or not","!type":"fn() -> bool"},"isActionAborted":{"!doc":"Determines whether the current database action is to be aborted. Available in Fuji patch 3","!type":"fn() -> bool"},"chooseWindow":{"!doc":"Sets a range of rows to be returned by subsequent queries. If forceCount is true, getRowCount() method will return all possible records","!type":"fn(firstRow: number, lastRow: number, forceCount: bool)"},"canWrite":{"!doc":"Determines if the Access Control Rules which include the user's roles permit editing records in this table","!type":"fn() -> bool"},"setTextSearchOpts":{"!doc":"Provide additional options for text search query","!type":"fn(textSearchOpts: ?)"},"canCreate":{"!doc":"Determines if the Access Control Rules which include the user's roles permit inserting new records in this table","!type":"fn() -> bool"},"setWorkflow":{"!doc":"Enables and disables the running of business rules and script engines. When disabled, inserts and updates are not audited","!type":"fn(e: bool)"},"getValue":{"!doc":"Retrieves the underlying value of a field","!type":"fn(fieldName: string) -> string"},"getLink":{"!doc":"Retrieves a link to the current record","!type":"fn(nostack: bool) -> string"},"getElement":{"!doc":"Retrieves the GlideElement for a specified field","!type":"fn(fieldName: string) -> +GlideElement"},"setValue":{"!doc":"Sets the value for the specified field.","!type":"fn(fieldName: string, value: ?)"},"getDisplayValue":{"!doc":"Retrieves the display value for the current record","!type":"fn(fieldName: string) -> string"},"isValidField":{"!doc":"Determines if the given field is defined in the current table","!type":"fn(fieldName: string) -> bool"},"initialize":{"!doc":"Creates an empty record suitable for population before an insert","!type":"fn()"},"operation":{"!doc":"Retrieves the current operation being performed, such as insert, update, or delete","!type":"fn() -> string"},"newRecord":{"!doc":"Creates a new GlideRecord, sets the default values for the fields, and assigns a unique ID to the record","!type":"fn()"},"deleteRecord":{"!doc":"Deletes the current record","!type":"fn() -> bool"}}},"sn_ws":{"":{"prototype":{}},"RESTResponseV2":{"!doc":"The RESTResponseV2 API allows you to use the data returned by an outbound REST message in JavaScript code. A RESTResponseV2 object is returned by the RESTMessageV2 functions execute() and executeAsync()","!type":"fn()","prototype":{"getStatusCode":{"!doc":"Get the numeric HTTP status code returned by the REST provider","!type":"fn(name: string) -> number"},"getHeaders":{"!doc":"Deprecated -- use getAllHeaders instead","!type":"fn() -> Object"},"waitForResponse":{"!doc":"Set the amount of time the instance waits for the response","!type":"fn(timeoutSecs: number)"},"getBody":{"!doc":"Get the content of the REST response body","!type":"fn() -> string"},"getErrorCode":{"!doc":"Get the numeric error code, if there was an error during the REST transaction","!type":"fn() -> number"},"getQueryString":{"!doc":"Get the error message if there was an error during the REST transaction","!type":"fn() -> string"},"getAllHeaders":{"!doc":"Get all headers returned in the REST response and the associated values","!type":"fn() -> [+GlideHTTPHeader]"},"haveError":{"!doc":"Indicate if there was an error during the REST transaction","!type":"fn() -> bool"},"getHeader":{"!doc":"Get the value for a specified header","!type":"fn(name: string) -> string"},"getErrorMessage":{"!doc":"Get the query used for this request","!type":"fn() -> string"}}},"!doc":"Web Services API, to send a message to a web service provider","SOAPMessageV2":{"!doc":"Instantiates a SOAPMessageV2 object. Specify optional message and a function if there is a SOAP message record","!type":"fn(soapMessage: string, soapFunction: string)","prototype":{"setMIDServer":{"!doc":"Configure the SOAP message to be sent through a MID Server","!type":"fn(midServerName: string)"},"getRequestBody":{"!doc":"Get the content of the SOAP message body","!type":"fn() -> string"},"getRequestHeader":{"!doc":"Get the value for an HTTP header specified by the SOAP client","!type":"fn(headerName: string) -> string"},"setBasicAuth":{"!doc":"Set basic authentication headers for the SOAP message","!type":"fn(userName: string, userPass: string)"},"setWSSecurityUsernameToken":{"!doc":"Set WS-Security Username token","!type":"fn(username: string, password: string)"},"setRequestHeader":{"!doc":"Set an HTTP header in the SOAP message to the specified value","!type":"fn(headerName: string, headerValue: string)"},"getEndpoint":{"!doc":"Get the URL of the endpoint for the SOAP message","!type":"fn() -> string"},"setWSSecurityX509Token":{"!doc":"Set WS-Security X.509 token","!type":"fn(keystoreId: string, keystoreAlias: string, keystorePassword: string, certificateId: string)"},"setStringParameterNoEscape":{"!doc":"Set a variable from the SOAP message record to the specified value without escaping XML reserved characters","!type":"fn(name: string, value: string)"},"execute":{"!doc":"Send the SOAP Message to the endpoint","!type":"fn() -> +sn_ws.SOAPResponse"},"setHttpTimeout":{"!doc":"Set the amount of time the request waits for a response from the web service provider before the request times out","!type":"fn(timeoutMs: number)"},"setEndpoint":{"!doc":"Set the endpoint for the SOAP message","!type":"fn(endpoint: string)"},"setRequestBody":{"!doc":"Set the body content to send to the web service provider","!type":"fn(requestBody: string)"},"getRequestHeaders":{"!doc":"Get name and value for all HTTP headers specified by the SOAP client","!type":"fn() -> Object"},"setStringParameter":{"!doc":"Set a variable from the SOAP message record to the specified value","!type":"fn(name: string, value: string)"},"setSOAPAction":{"!doc":"Define the SOAP action this SOAP message performs","!type":"fn(soapAction: string)"},"setMutualAuth":{"!doc":"Set the mutual authentication protocol profile for the SOAP message","!type":"fn(profileName: string)"},"setEccCorrelator":{"!doc":"Associate outbound requests and the resulting response record in the ECC queue","!type":"fn(correlator: string)"},"setWSSecurity":{"!doc":"Set web service security values for the SOAP message","!type":"fn(keystoreId: string, keystoreAlias: string, keystorePassword: string, certificateId: string)"},"setEccParameter":{"!doc":"Override a value from the database by writing to the SOAP message payload","!type":"fn(name: string, value: string)"},"executeAsync":{"!doc":"Send the SOAP Message to the endpoint asynchronously","!type":"fn() -> +sn_ws.SOAPResponse"}}},"SOAPResponseV2":{"!doc":"The SOAPResponseV2 API allows you to use the data returned by an outbound SOAP message in JavaScript code. A SOAPResponseV2 object is returned by the SOAPMessageV2 functions execute() and executeAsync()","!type":"fn()","prototype":{"getStatusCode":{"!doc":"Get the numeric HTTP status code returned by the SOAP provider","!type":"fn() -> number"},"getHeaders":{"!doc":"Deprecated -- use getAllHeaders instead","!type":"fn() -> Object"},"waitForResponse":{"!doc":"Set the amount of time the instance waits for a response","!type":"fn(timeoutSecs: number)"},"getBody":{"!doc":"Get the content of the SOAP response body","!type":"fn() -> string"},"getErrorCode":{"!doc":"Get the numeric error code if there was an error during the SOAP transaction","!type":"fn() -> number"},"getAllHeaders":{"!doc":"Get all HTTP headers returned in the SOAP response and the associated values","!type":"fn() -> [+GlideHTTPHeader]"},"haveError":{"!doc":"Indicate if there was an error during the SOAP transaction","!type":"fn() -> bool"},"getHeader":{"!doc":"Get the value for a specified HTTP header","!type":"fn(name: string)-> string"},"getErrorMessage":{"!doc":"Get the error message if there was an error during the SOAP transaction","!type":"fn() -> string"}}},"RESTMessageV2":{"!doc":"Instantiates a RESTMessageV2 object. When you have a REST message record, you can add the optional name and methodName information","!type":"fn(name: string, methodName: string)","prototype":{"setMIDServer":{"!doc":"Configure the REST message to communicate through a MID Server","!type":"fn(midServer: string)"},"getRequestBody":{"!doc":"Get the content of the REST message body","!type":"fn() -> string"},"getRequestHeader":{"!doc":"Get the value for an HTTP header specified by the REST client","!type":"fn(headerName: string) -> string"},"setHttpMethod":{"!doc":"The HTTP method this REST message performs, such as GET or PUT. You must set an HTTP method when using the RESTMessageV2() constructor with no parameters","!type":"fn(method: string)"},"setBasicAuth":{"!doc":"Set basic authentication headers for the REST message","!type":"fn(userName: string, userPass: string)"},"setRequestHeader":{"!doc":"Set an HTTP header to the specified value","!type":"fn(name: string, value: string)"},"setAuthenticationProfile":{"!doc":"Set the credentials for the REST message using an existing basic auth or OAuth 2.0 profile. Valid types are 'basic' and 'oauth2'. Valid profileIds are the sys_id of a Basic Auth Configuration [sys_auth_profile_basic] record or an OAuth Entity Profile [oauth_entity_profile] record","!type":"fn(type: string, profileId: string)"},"setQueryParameter":{"!doc":"Append a name-value parameter to the request URL","!type":"fn(name: string, value: string)"},"setRequestBodyFromAttachment":{"!doc":"Uses the specified attachment as the request body of this REST Message. Mutually exclusive with setRequestBody","!type":"fn(attachmentSysId: string)"},"getEndpoint":{"!doc":"Get the URL of the endpoint for the REST message","!type":"fn() -> string"},"setStringParameterNoEscape":{"!doc":"Set a REST message function variable to the specified value without escaping XML reserved characters","!type":"fn(name: string, value: string)"},"execute":{"!doc":"Send the REST message to the endpoint","!type":"fn() -> +sn_ws.RESTResponseV2"},"setHttpTimeout":{"!doc":"Set the amount of time the REST message waits for a response from the REST provider","!type":"fn(timeoutMs: number)"},"setEndpoint":{"!doc":"Set the endpoint for the REST message","!type":"fn(endpoint: string)"},"setRequestBody":{"!doc":"Set the body content of a PUT or POST request. Mutually exclusive with setRequestBodyFromAttachment","!type":"fn(body: string)"},"getRequestHeaders":{"!doc":"Get name and value for all HTTP headers specified by the REST client","!type":"fn() -> Object"},"saveResponseBodyAsAttachment":{"!doc":"Setup the response body to be saved into the specified attachment when the request is sent. encryptCtxSysId is optional","!type":"fn(tableName: string, recordSysId: string, filename: string, encryptCtxSysId: string)"},"setStringParameter":{"!doc":"Set a REST message function variable to the specified value","!type":"fn(name: string, value: string)"},"setMutualAuth":{"!doc":"Set the mutual authentication protocol profile for the REST message","!type":"fn(profileName: string)"},"setEccTopic":{"!doc":"Set the ECC topic for the REST message. The default ECC topic is RESTProbe if topic is not set. In most cases it is unnecessary to set ECC topic","!type":"fn(topic: string)"},"setEccCorrelator":{"!doc":"Associate outbound requests and the resulting response record in the ECC queue","!type":"fn(correlator: string)"},"setEccParameter":{"!doc":"Override a value from the database by writing to the REST message payload","!type":"fn(name: string, value: string)"},"executeAsync":{"!doc":"Send the REST message to the endpoint asynchronously. The instance does not wait for a response from the web service provider when making asynchronous calls","!type":"fn() -> +sn_ws.RESTResponseV2"},"getEccTopic":{"!doc":"Get the ECC topic for the REST message","!type":"fn() -> string"}}}},"GlideServletResponse":{"!doc":"ServiceNow processors are equivalent to Java servlets. Processors provide a customizable URL endpoint that can execute arbitrary server-side Javascript code and produce output such as TEXT, JSON, or HTML. The GlideServletResponse API is used in processor scripts to access the HttpServletResponse object. The GlideServletResponse object provides a subset of the HttpServletResponse APIs. The methods are called using the global variable g_response. A useful global variable, g_target, is available in processor scripts. It contains the table name extracted from the URL. The URL to a processor has the format: https://<instance name.servicenow.com>/<path endpoint>.do?<parameter endpoint>=<value> where the path endpoint and parameter endpoint are defined on the processor form","!type":"fn()","prototype":{"setContentType":{"!doc":"Sets the MIME type of the response","!type":"fn(type: string)"},"sendRedirect":{"!doc":"Sends a temporary redirect to the client","!type":"fn(location: string)"},"setStatus":{"!doc":"Sets the status code for the response","!type":"fn(status: number)"},"setHeader":{"!doc":"Sets a response header to the specified value","!type":"fn(key: string, value: string)"}}},"GlideElementDescriptor":{"!doc":"The scoped GlideElementDescriptor class provides information about individual fields","!type":"fn()","prototype":{"getName":{"!doc":"Returns the field's name","!type":"fn() -> string"},"getInternalType":{"!doc":"Returns the field's data type","!type":"fn() -> string"},"getLabel":{"!doc":"Returns the field's label","!type":"fn() -> string"},"getLength":{"!doc":"Returns the field's length","!type":"fn() -> number"}}},"GlideQueryCondition":{"!doc":"The scoped QueryCondition API provides additional AND or OR conditions that can be added to the current condition, allowing you to build complex queries such as: category='hardware' OR category='software' AND priority='2' AND priority='1'","!type":"fn()","prototype":{"addOrCondition":{"!doc":"Adds an OR condition to the current condition. oper is an optional parameter","!type":"fn(name: string, oper: string, value: ?) -> +GlideQueryCondition"},"addCondition":{"!doc":"Adds an AND condition to the current condition. oper is an optional parameter","!type":"fn(name: string, oper: string, value: ?) -> +GlideQueryCondition"}}},"GlideScriptableInputStream":{"!doc":"A wrapper around an InputStream. No functions are provided to manipulate the stream from script. Rather this object can be passed to any API which takes an InputStream as an input parameter","!type":"fn()"},"GlideRecordSecure":{"!doc":"GlideRecordSecure is a class inherited from GlideRecord that performs the same functions as GlideRecord, and also enforces ACLs","!type":"GlideRecord"},"XMLDocument2":{"!doc":"XMLDocument2 is a JavaScript Object wrapper for parsing and extracting XML data from an XML string. Use this JavaScript class to instantiate an object from an XML string, usually a return value from a Web Service invocation, or the XML payload of ECC Queue","!type":"fn()","prototype":{"getFirstNode":{"!doc":"Gets the first node in the specified xpath","!type":"fn(xpath: string) -> +XMLNode"},"createElementWithTextValue":{"!doc":"Creates an element node with a text child node and adds it to the current node","!type":"fn(name: string, value: string) -> +XMLNode"},"getNextNode":{"!doc":"Gets the node after the specified node","!type":"fn(prev: +XMLNode) -> +XMLNode"},"isValid":{"!doc":"Checks if the XMLDocument is valid","!type":"fn() -> bool"},"setCurrentElement":{"!doc":"Makes the node passed in as a parameter the current node","!type":"fn(element: +XMLNode)"},"getDocumentElement":{"!doc":"Gets the document element node of the XMLDocument2. The document element node is the root node","!type":"fn() -> +XMLNode"},"parseXML":{"!doc":"Parses the XML string and loads it into the XMLDocument2 object","!type":"fn(xmlDoc: string) -> bool"},"createElement":{"!doc":"Creates and adds an element node to the current node. The element name is the string passed in as a parameter. The new element node has no text child nodes","!type":"fn(name: string) -> +XMLNode"},"toString":{"!doc":"Returns a string containing the XML","!type":"fn() -> string"},"getNode":{"!doc":"Gets the node specified in the xpath","!type":"fn(xpath: string) -> +XMLNode"},"getNodeText":{"!doc":"Gets all the text child nodes from the node referenced in the xpath","!type":"fn(xpath: string) -> string"}}},"GlideDuration":{"!doc":"The scoped GlideDuration class provides methods for working with spans of time or durations. GlideDuration objects store the duration as a date and time from January 1, 1970, 00:00:00. As a result, setValue() and getValue() use the GlideDateTime object for parameters and return values","!type":"fn()","prototype":{"add":{"!doc":"Adds a given duration to the current duration","!type":"fn(value: +GlideDuration) -> +GlideDuration"},"getByFormat":{"!doc":"Gets the current duration in the given format","!type":"fn(format: string) -> string"},"getValue":{"!doc":"Gets internal value of the this duration object. GlidDuration is stored as DateTime","!type":"fn() -> string"},"subtract":{"!doc":"","!type":"fn(value: +GlideDuration) -> +GlideDuration"},"getDisplayValue":{"!doc":"Gets the display value of the duration in number of days, hours, and minutes","!type":"fn() -> string"},"setValue":{"!doc":"Sets the internal value of the GlideDuration object. Internally, GlidDuration is stored as DateTime","!type":"fn(o: ?)"},"getDayPart":{"!doc":"Gets the number of days","!type":"fn() -> number"},"setDisplayValue":{"!doc":"Sets the display value","!type":"fn(asDisplayed: string)"},"getRoundedDayPart":{"!doc":"Gets the rounded number of days. If the time part is more than 12 hours, the return value is rounded up. Otherwise, it is rounded down","!type":"fn() -> number"},"getDurationValue":{"!doc":"Gets the duration value in d HH:mm:ss format","!type":"fn() -> string"}}},"GlideAggregate":{"!doc":"The scoped GlideAggregate class is an extension of GlideRecord and allows database aggregation (COUNT, SUM, MIN, MAX, AVG) queries to be done. This can be helpful in creating customized reports or in calculations for calculated fields. The GlideAggregate class works only on number fields. Since currency fields are strings, you can't use the GlideAggregate class on currency fields","!type":"fn(tableName: string)","prototype":{"next":{"!doc":"Moves to the next record in the GlideAggregate","!type":"fn() -> bool"},"getRowCount":{"!doc":"Retrieves the number of rows in the GlideRecord","!type":"fn() -> number"},"getAggregateEncodedQuery":{"!doc":"Gets the query necessary to return the current aggregate","!type":"fn() -> string"},"addAggregate":{"!doc":"Adds an aggregate","!type":"fn(aggregate: string, field: string)"},"query":{"!doc":"Issues the query and gets the results","!type":"fn()"},"getTableName":{"!doc":"Retrieves the table name associated with this GlideRecord","!type":"fn() -> string"},"orderBy":{"!doc":"Orders the aggregates using the value of the specified field. The field will also be added to the group-by list","!type":"fn(field: string)"},"orderByDesc":{"!doc":"Sorts the aggregates into descending order based on the specified field","!type":"fn(field: string)"},"hasNext":{"!doc":"Determines if there are any more results in the GlideAggregate","!type":"fn() -> bool"},"groupBy":{"!doc":"Provides the name of a field to use in grouping the aggregates. May be called numerous times to set multiple group fields","!type":"fn(field: string)"},"getEncodedQuery":{"!doc":"Retrieves the encoded query","!type":"fn() -> string"},"addNotNullQuery":{"!doc":"Adds a NOT NULL query to the aggregate","!type":"fn(field: string) -> +GlideQueryCondition"},"orderByAggregate":{"!doc":"Sorts the aggregates based on the specified aggregate and field","!type":"fn(aggregate: string, field: string)"},"addNullQuery":{"!doc":"Adds a NULL query to the aggregate","!type":"fn(field: string) -> +GlideQueryCondition"},"getValue":{"!doc":"Gets the value of a field","!type":"fn(field: string) -> string"},"setGroup":{"!doc":"Sets whether the results are to be grouped","!type":"fn(value: bool)"},"addEncodedQuery":{"!doc":"Adds a query to the aggregate. Adds an encoded query to the other queries that may have been set for this aggregate","!type":"fn(query: string)"},"addQuery":{"!doc":"Adds a query to the aggregate","!type":"fn(field: string, operator: string, value: string) -> +GlideQueryCondition"},"getAggregate":{"!doc":"Gets the value of the specified aggregate","!type":"fn(aggregate: string, field: string) -> string"}}},"sn_ws_err":{"":{"prototype":{}},"NotAcceptableError":{"!doc":"Sets status code 406 and includes the specified message in the response","!type":"fn(message: string)"},"ServiceError":{"!doc":"A generic error message wrapper to set status code and detailed error message in the response","!type":"fn()","prototype":{"setDetail":{"!doc":"The detailed error message","!type":"fn(detail: string)"},"setMessage":{"!doc":"The error message","!type":"fn(message: string)"},"setStatus":{"!doc":"The response status code -- defaults to 500","!type":"fn(code: number)"}}},"UnsupportedMediaTypeError":{"!doc":"Sets status code 415 and includes the specified message in the response","!type":"fn(message: string)"},"ConflictError":{"!doc":"Sets status code 409 and includes the specified message in the response","!type":"fn(message: string)"},"!doc":"Error types which can be set as the response body of a Scripted REST API","NotFoundError":{"!doc":"Sets status code 404 and includes the specified message in the response","!type":"fn(message: string)"},"BadRequestError":{"!doc":"Sets status code 400 and includes the specified message in the response","!type":"fn(message: string)"}},"GlideSession":{"!doc":"GlideSession manages all of the information for a user session. You can retrieve this from gs.getSession()","!type":"fn()","prototype":{"getTimeZoneName":{"!doc":"Get the Time Zone name associated with the user","!type":"fn() -> string"},"putClientData":{"!doc":"Store a value in an active session","!type":"fn(name: string, value: string)"},"getLanguage":{"!doc":"Language used by the user","!type":"fn() -> string"},"getUrlOnStack":{"!doc":"Gets the current URI for the session","!type":"fn() -> string"},"getClientData":{"!doc":"Fetch the value in active session based on the name","!type":"fn(name: string) -> string"},"isInteractive":{"!doc":"Checks if the current session is interactive","!type":"fn() -> bool"},"getClientIP":{"!doc":"Gets the client IP address","!type":"fn() -> string"},"isLoggedIn":{"!doc":"Determines if the current user is currently logged in","!type":"fn() -> bool"},"getCurrentApplicationId":{"!doc":"Gets the ID of current application, defined as a user preference and set by the application picker","!type":"fn() -> string"}}},"gs":{"monthsAgo":{"!doc":"Returns the (UTC) start of the quarter that was the specified number of months ago adjusted for the timezone of the server","!type":"fn(month: number) -> string"},"hoursAgoEnd":{"!doc":"Returns the (UTC) end of the hour that was the specified number of hours ago adjusted for the timezone of the server","!type":"fn(hours: number) -> string"},"endOfThisMonth":{"!doc":"Gets the date and time for the end of this month in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"isInteractive":{"!doc":"Checks if the current session is interactive","!type":"fn() -> bool"},"daysAgoEnd":{"!doc":"Returns the (UTC) end of the day that was the specified number of days ago adjusted for the timezone of the server","!type":"fn(daysAgo: number) -> string"},"beginningOfNextMonth":{"!doc":"Gets the date and time for the beginning of next month in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"hoursAgo":{"!doc":"number of hours ago","!type":"fn(hours: number) -> string"},"quartersAgoEnd":{"!doc":"Returns the (UTC) end of the quarter that was the specified number of quarters ago adjusted for the timezone of the server","!type":"fn(quarters: number) -> string"},"beginningOfThisYear":{"!doc":"Gets the date and time for the beginning of this year in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"getCurrentApplicationId":{"!doc":"Gets the ID of current application, defined as a user preference and set by the application picker","!type":"fn() -> string"},"endOfLastYear":{"!doc":"Gets the date and time for the end of last year in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"endOfNextYear":{"!doc":"Gets the date and time for the end of next year in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"nil":{"!doc":"Queries an object and returns true if the object is null, undefined, or contains an empty string","!type":"fn(o: Object) -> bool"},"beginningOfThisQuarter":{"!doc":"Gets the date and time for the beginning of this quarter in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"isDebugging":{"!doc":"Determines if debugging is active for a specific scope","!type":"fn() -> bool"},"setRedirect":{"!doc":"Set the redirect URI for this transaction. This determines the next page the user will see","!type":"fn(url: string)"},"datePart":{"!doc":"Returns a String of the form :interval,value,operator","!type":"fn(interval: string, value: string, operator: string) -> string"},"generateGUID":{"!doc":"Generates a GUID that can be used when a unique identifier is required","!type":"fn(obj: Object) -> string"},"getNewAppScopeCompanyPrefix":{"!doc":"","!type":"fn() -> string"},"getUserName":{"!doc":"Gets the username, or User ID, of the current user (e.g., abel.tuter)","!type":"fn() -> string"},"info":{"!doc":"Uses the info level to log a message to the system log","!type":"fn(message: string, parm1: Object, parm2: Object, parm3: Object, parm4: Object, parm5: Object)"},"base64Encode":{"!doc":"","!type":"fn(s: string) -> string"},"getUrlOnStack":{"!doc":"Gets the current URI for the session","!type":"fn() -> string"},"monthsAgoStart":{"!doc":"Returns the (UTC) start of the quarter that was the specified number of months ago adjusted for the timezone of the server","!type":"fn(month: number) -> string"},"getCssCacheVersionString":{"!doc":"Gets a string representing the cache version for a CSS file","!type":"fn() -> string"},"getCallerScopeName":{"!doc":"Gets the caller scope name, or returns null if there is no caller","!type":"fn() -> string"},"base64Decode":{"!doc":"","!type":"fn(s: string) -> string"},"minutesAgo":{"!doc":"number of minutes ago","!type":"fn(minutes: number) -> string"},"hoursAgoStart":{"!doc":"Returns the (UTC) start of the hour that was the specified number of hours ago adjusted for the timezone of the server","!type":"fn(hours: number) -> string"},"warn":{"!doc":"Uses the warn level to log a message to the system log","!type":"fn(message: string, parm1: Object, parm2: Object, parm3: Object, parm4: Object, parm5: Object)"},"endOfNextWeek":{"!doc":"Returns the (UTC) end of next week adjusted for the timezone of the server","!type":"fn() -> string"},"beginningOfLastWeek":{"!doc":"Gets the date and time for the beginning of last week in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"hasRole":{"!doc":"Determines if the current user has the specified role","!type":"fn(role: string) -> bool"},"isLoggedIn":{"!doc":"Determines if the current user is currently logged in","!type":"fn() -> bool"},"endOfThisWeek":{"!doc":"Gets the date and time for the end of this week in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"getUserDisplayName":{"!doc":"Gets the display name of the current user (e.g., Abel Tuter, as opposed to abel.tuter)","!type":"fn() -> string"},"beginningOfThisWeek":{"!doc":"Gets the date and time for the beginning of this week in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"getUser":{"!doc":"Returns a reference to the GlideUser object for the current user","!type":"fn() -> +GlideUser"},"urlDecode":{"!doc":"","!type":"fn(url: string) -> string"},"beginningOfLastYear":{"!doc":"Gets the date and time for the beginning of last year in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"tableExists":{"!doc":"Determines if a database table exists","!type":"fn(name: string) -> bool"},"error":{"!doc":"Uses the error level to log a message to the system log","!type":"fn(message: string, parm1: Object, parm2: Object, parm3: Object, parm4: Object, parm5: Object)"},"urlEncode":{"!doc":"","!type":"fn(url: string) -> string"},"endOfThisYear":{"!doc":"Gets the date and time for the end of this year in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"getCurrentScopeName":{"!doc":"Gets the name of the current scope","!type":"fn() -> string"},"yesterday":{"!doc":"Returns (UTC) 24 hours ago adjusted for the timezone of the current session","!type":"fn() -> string"},"daysAgoStart":{"!doc":"Returns the (UTC) start of the day that was the specified number of days ago adjusted for the timezone of the server","!type":"fn(daysAgo: number) -> string"},"beginningOfLastMonth":{"!doc":"Gets the date and time for the beginning of last month in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"beginningOfThisMonth":{"!doc":"Gets the date and time for the beginning of this month in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"beginningOfNextYear":{"!doc":"Gets the date and time for the beginning of next year in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"getDurationDate":{"!doc":"Returns the date of the duration time after January 1","!type":"fn(duration: string) -> string"},"addErrorMessage":{"!doc":"Adds an error message for the current session","!type":"fn(message: string)"},"beginningOfWeek":{"!doc":"Returns the (UTC) beginning of the specified week adjusted for the timezone of the current session","!type":"fn(o: Object) -> string"},"minutesAgoEnd":{"!doc":"Returns the (UTC) end of the minute that was the specified number of minutes ago adjusted for the timezone of the serve","!type":"fn(minutes: number) -> string"},"getSessionID":{"!doc":"Gets the GlideSession Session ID","!type":"fn() -> string"},"endOfNextMonth":{"!doc":"Gets the date and time for the end of next month in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"getUserID":{"!doc":"Gets the sys_id of the current user","!type":"fn() -> string"},"include":{"!doc":"Provides a safe way to call from the sandbox, allowing only trusted scripts to be included","!type":"fn(name: string) -> bool"},"daysAgo":{"!doc":"Returns the (UTC) start of the day that was the specified number of days ago adjusted for the timezone of the server","!type":"fn(days: number) -> string"},"minutesAgoStart":{"!doc":"Returns the (UTC) start of the minute that was the specified number of minutes ago adjusted for the timezone of the serve","!type":"fn(minutes: number) -> string"},"getProperty":{"!doc":"Retrieves a message from UI messages","!type":"fn(key: string, alt: Object) -> string"},"endOfWeek":{"!doc":"Returns the (UTC) end of the specified week adjusted for the timezone of the current session","!type":"fn(o: Object) -> string"},"endOfLastMonth":{"!doc":"Gets the date and time for the end of last month in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"debug":{"!doc":"Uses the debug level to log a message to the system log","!type":"fn(message: string, parm1: Object, parm2: Object, parm3: Object, parm4: Object, parm5: Object)"},"!doc":"The scoped GlideSystem (referred to by the variable name 'gs' in any server-side JavaScript) API provides a number of convenient methods to get information about the system, the current logged in user, etc.","getMessage":{"!doc":"Retrieves a message from UI messages. args is an optional paramter","!type":"fn(id: string, args: ?) -> string"},"endOfThisQuarter":{"!doc":"Gets the date and time for the end of this quarter in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"eventQueue":{"!doc":"Queues an event for the event manager","!type":"fn(name: string, record: +GlideRecord, parm1: string, parm2: string, queue: string)"},"xmlToJSON":{"!doc":"","!type":"fn(xmlString: string) -> +Object"},"addInfoMessage":{"!doc":"Adds an info message for the current session","!type":"fn(message: string)"},"beginningOfNextWeek":{"!doc":"Gets the date and time for the beginning of next week in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"getMaxSchemaNameLength":{"!doc":"","!type":"fn() -> number"},"endOfLastWeek":{"!doc":"Returns the (UTC) end of last week adjusted for the timezone of the server","!type":"fn() -> string"},"quartersAgoStart":{"!doc":"Returns the (UTC) start of the quarter that was the specified number of quarters ago adjusted for the timezone of the server","!type":"fn(quarters: number) -> string"},"getSession":{"!doc":"Gets a reference to the current Glide session","!type":"fn() -> +GlideSession"}},"GlideFilter":{"!doc":"The scoped GlideFilter class allows you to determine if a record meets a specified set of requirements. There is no constructor for scoped GlideFilter, it is accessed by using the global object 'GlideFilter'","checkRecord":{"!doc":"Returns true when the record meets the filter condition","!type":"fn(gr: +GlideRecord, filter: string, value: bool) -> bool"},"!type":"fn()"},"GlideDate":{"!doc":"The scoped GlideDate class provides methods for performing operations on GlideDate objects, such as instantiating GlideDate objects or working with GlideDate fields","!type":"fn()","prototype":{"getByFormat":{"!doc":"Gets the date in the given date format","!type":"fn(format: string) -> string"},"getMonthNoTZ":{"!doc":"Returns the month part of a date with no timezone conversion","!type":"fn() -> number"},"getValue":{"!doc":"Gets the date value stored in the database by the GlideDate object in the internal format, yyyy-MM-dd, and the system time zone, UTC by default","!type":"fn() -> string"},"getYearNoTZ":{"!doc":"Returns the year part of a date with no timezone conversion","!type":"fn() -> number"},"subtract":{"!doc":"Gets the duration difference between two GlideDate values","!type":"fn(start: +GlideDate, end: +GlideDate) -> +GlideDuration"},"getDisplayValue":{"!doc":"Gets the date in the current user's display format and time zone","!type":"fn() -> string"},"setValue":{"!doc":"Sets the date of the GlideDate object","!type":"fn(o: ?)"},"getDisplayValueInternal":{"!doc":"Gets the display value in the internal format (yyyy-MM-dd). Note: This method is useful for date or time fields, but not date fields","!type":"fn() -> string"},"getDayOfMonthNoTZ":{"!doc":"Returns the day part of a date with no timezone conversion","!type":"fn() -> number"},"setDisplayValue":{"!doc":"Sets a date value using the current user's display format and time zone","!type":"fn(asDisplayed: string)"}}},"GlideScriptedProcessor":{"!doc":"ServiceNow processors are equivalent to Java servlets. Processors provide a customizable URL endpoint that can execute arbitrary server-side Javascript code and produce output such as TEXT, JSON, or HTML. The GlideScriptedProcessor APIs are used in processor scripts to access the the processor (servlet) capabilities. There are no constructors for the GlideScriptedProcessor APIs. The methods are called using the global variable g_processor. A useful global variable, g_target, is available in processor scripts. It contains the table name extracted from the URL. The URL to a processor has the format: https://<instance name.servicenow.com>/<path endpoint>.do?<parameter endpoint>=<value> where the path endpoint and parameter endpoint are defined on the processor form","!type":"fn()","prototype":{"redirect":{"!doc":"Redirects to the specified URL","!type":"fn(url: string)"},"writeOutput":{"!doc":"Writes the contents of the given string to the response","!type":"fn(contentType: string, value: string)"},"writeJSON":{"!doc":"Writes a JSON object to the current URL. Note: Works only in scoped apps","!type":"fn(jsonObject: ?)"}}},"sn_ws_int":{"":{"prototype":{}},"WSSoapRequestDocument":{"!doc":"SOAP request object as a DOM Document or XMLDocument2 (for new application scope)","!type":"Object"},"!doc":"These objects are relevant to Scripted REST APIs and are accessed via the request or response input parameters to Scripted APIs","RESTAPIResponseStream":{"!doc":"Allows you to write streams or strings directly to the response stream in a Scripted REST API","!type":"fn()","prototype":{"writeStream":{"!doc":"Write an InputStream directly to the response stream. Can be called multiple times. Caller responsible for response format and setting proper Content-Type and status code prior to calling","!type":"fn(inputStream: Object)"},"writeString":{"!doc":"Write a string directly to the response stream. Can be called multiple times. Caller responsible for response format and setting proper Content-Type and status code prior to calling","!type":"fn(stringToWrite: string)"}}},"RESTAPIResponse":{"!doc":"Allows you to configure the HTTP response in Scripted REST APIs","!type":"fn()","prototype":{"setHeaders":{"!doc":"Set response headers from the specified object","!type":"fn(headers: ?)"},"getStreamWriter":{"!doc":"Return stream writer. Caller responsible to set proper content type and status using setStatus and setHeader methods. Caller responsible to populate all headers on response before actually writing to stream","!type":"fn() -> +sn_ws_int.RESTAPIResponseStream"},"setLocation":{"!doc":"Set the Location header","!type":"fn(locationValue: string)"},"setError":{"!doc":"Set Response Error","!type":"fn(error: ?)"},"setContentType":{"!doc":"Set the Content-Type header","!type":"fn(contentType: string)"},"setBody":{"!doc":"Use the specified object as the response body","!type":"fn(body: ?)"},"setStatus":{"!doc":"Set response HTTP status code","!type":"fn(code: number)"},"setHeader":{"!doc":"Set a response header","!type":"fn(name: string, value: string)"}}},"WSRequest":{"!doc":"Provides access to request input parameters","!type":"fn()","prototype":{"<input parameter name>":{"!doc":"Use request.<parameter name> to get the value of an input parameter"}}},"WSResponse":{"!doc":"Allows setting response output parameters","!type":"fn()","prototype":{"<output parameter name>":{"!doc":"Use response.<parameter name> to assign a value to an output parameter"},"soapResponseElement":{"!doc":"Use this variable to assign a response value as a DOM Element"}}},"WSSoapRequestXML":{"!doc":"SOAP request object as a String","!type":"string"},"RESTAPIRequest":{"!doc":"Allows you to access request details in Scripted REST APIs","!type":"fn()","prototype":{"headers":{"!doc":"All headers from the request"},"pathParams":{"!doc":"The variable path parameters passed in the request URI as an object"},"queryParams":{"!doc":"The query parameters from the request as an object"},"getRequestedQueryCategory":{"!doc":"Get the query category (i.e. read replica category) from query parameter 'sysparm_query_category'","!type":"fn() -> string"},"getSupportedResponseContentTypes":{"!doc":"Obtain a set of media types that are common between what the client request accepts and what this service is able to produce","!type":"fn() -> Object"},"body":{"!doc":"The body of the request","!type":"+sn_ws_int.RESTAPIRequestBody"},"queryString":{"!doc":"The entire query string from the request URI","!type":"string"},"uri":{"!doc":"The request URI, excluding domain information","!type":"string"},"url":{"!doc":"The entire request URL, including domain","!type":"string"},"getHeader":{"!doc":"Get the value of a specific header from the request","!type":"fn(headerName: string) -> string"}}},"RESTAPIRequestBody":{"!doc":"Allows you to access the request body as a stream, as a string, de-serialized into an object, or as an array of obects","!type":"fn()","prototype":{"nextEntry":{"!doc":"Returns the next entry from the request body as an object if request is array. If not an array then returns entire request body as an object","!type":"fn() -> Object"},"data":{"!doc":"The request body de-serialized as an object"},"dataString":{"!doc":"The request body as a string -- be careful to consider impact to memory","!type":"string"},"dataStream":{"!doc":"The body of the request as a stream. Note, this object provides no functions to manipulate the stream from script. Rather this object can be passed to another API which takes an InputStream as an input parameter","!type":"+GlideScriptableInputStream"},"hasNext":{"!doc":"Return true if request has more entries. Use this in conjunction with nextEntry","!type":"fn() -> bool"}}}},"GlideTime":{"!doc":"The scoped GlideTime class provides methods for performing operations on GlideTime objects, such as instantiating GlideTime objects or working with GlideTime fields","!type":"fn()","prototype":{"getByFormat":{"!doc":"Gets the time in the given time format","!type":"fn(format: string) -> string"},"subtract":{"!doc":"Gets the duration difference between two GlideTime values","!type":"fn(start: +GlideTime, end: +GlideTime) -> +GlideDuration"},"getHourLocalTime":{"!doc":"Returns hour part of local time 0-11","!type":"fn() -> number"},"setDisplayValue":{"!doc":"Sets a time value using the current user's display format and time zone","!type":"fn(asDisplayed: string)"},"getHourUTC":{"!doc":"Returns hour part of UTC time 0-11","!type":"fn() -> number"},"getValue":{"!doc":"Gets the time value stored in the database by the GlideTime object in the internal format, HH:mm:ss, and the system time zone, UTC by default","!type":"fn() -> string"},"getMinutesUTC":{"!doc":"Returns minutes part of UTC time","!type":"fn() -> number"},"getSeconds":{"!doc":"Returns seconds part of time","!type":"fn() -> number"},"getDisplayValue":{"!doc":"Gets the time in the current user's display format and time zone","!type":"fn() -> string"},"setValue":{"!doc":"Sets the time of the GlideTime object in the internal time zone, which is UTC by default or the value of the glide.sys.internal.tz property, if set","!type":"fn(value: ?)"},"getDisplayValueInternal":{"!doc":"Gets the display value in the current user's time zone and the internal format (HH:mm:ss). Useful for date/time fields, but not for date fields","!type":"fn() -> string"},"getHourOfDayLocalTime":{"!doc":"Returns hour-of-the-day part of local time 0-23","!type":"fn() -> number"},"getHourOfDayUTC":{"!doc":"Returns the hour-of-the-day part of UTC time 0-23","!type":"fn() -> number"},"getMinutesLocalTime":{"!doc":"Returns minutes part of local time","!type":"fn() -> number"}}},"GlideUser":{"!doc":"The Scoped GlideUser API provides access to information about the current user and current user roles. Using the Scoped GlideUser API avoids the need to use the slower GlideRecord queries to get user information","!type":"fn()","prototype":{"getName":{"!doc":"Gets the user id, or login name, of the current user","!type":"fn() -> string"},"getDisplayName":{"!doc":"Gets the display name of the current user","!type":"fn() -> string"},"getCompanyID":{"!doc":"Gets the Company ID of the current user","!type":"fn() -> string"},"hasRole":{"!doc":"Determines if the current user has the specified role","!type":"fn(role: string) -> bool"},"getID":{"!doc":"Gets the sys_id of current user","!type":"fn() -> string"},"isMemberOf":{"!doc":"Determines if the current user is a member of the specified group","!type":"fn(group: string) -> bool"},"savePreference":{"!doc":"Saves a user preference value to the database","!type":"fn(name: string, value: string)"},"getPreference":{"!doc":"Gets the specified user preference value for the current user","!type":"fn(name: string) -> string"}}},"GlideSchedule":{"!doc":"The scoped GlideSchedule API provides methods for performing operations on GlideSchedule objects, such as adding new schedule segments to a schedule, determining if a datetime is within the schedule, or setting the schedule timezone","!type":"fn()","prototype":{"add":{"!doc":"Adds a new schedule segment to the current schedule","!type":"fn(startDate: +GlideDateTime, offset: +GlideDuration) -> GlideDateTime"},"duration":{"!doc":"Determines the elapsed time in the schedule between two date time values using the timezone of the schedule or, if that is not specified, the timezone of the session","!type":"fn(startDate: +GlideDateTime, endDate: +GlideDateTime) -> +GlideDuration"},"getName":{"!doc":"Gets the current schedule name","!type":"fn() -> string"},"load":{"!doc":"Loads a schedule with the schedule information. If a timezone is not specified or is nil, the current session timezone is used for the schedule","!type":"fn(sysID: string, timeZone: string, excludeSpanID: string)"},"isValid":{"!doc":"Determines if the current schedule is valid. A schedule is valid if it has at least one schedule span","!type":"fn() -> bool"},"setTimeZone":{"!doc":"Sets the timezone for the current schedule","!type":"fn(tz: string)"}}},"GlideElement":{"!doc":"The Scoped GlideElement API provides methods for dealing with fields and their values. Scoped GlideElement methods are available for the fields of the current GlideRecord","!type":"fn()","prototype":{"getCurrencyCode":{"!doc":"Gets the currency ISO code for a record","!type":"fn() -> string"},"getLabel":{"!doc":"Gets the object's label","!type":"fn() -> string"},"getName":{"!doc":"Gets the name of the field","!type":"fn() -> string"},"getBooleanAttribute":{"!doc":"Gets the value of the attribute on the field in question from the dictionary as a string. To get the value as a string, use getAttribute(string)","!type":"fn(attribute: string) -> bool"},"canRead":{"!doc":"Determines if the GlideRecord table can be read from","!type":"fn() -> bool"},"changes":{"!doc":"Determines if the current field has been modified","!type":"fn() -> bool"},"getReferenceDisplayValue":{"!doc":"Gets the display value","!type":"fn() -> string"},"getCurrencyString":{"!doc":"Gets currency in a string","!type":"fn() -> string"},"getReferenceTable":{"!doc":"Gets table name for a reference field","!type":"fn() -> string"},"getReferenceValue":{"!doc":"Gets the reference value","!type":"fn() -> string"},"nil":{"!doc":"Determines whether the field is null","!type":"fn() -> bool"},"getSessionDisplayValue":{"!doc":"Gets the currency value in the sessions currency format","!type":"fn() -> string"},"getDecryptedValue":{"!doc":"Gets the decrypted value","!type":"fn() -> string"},"getAttribute":{"!doc":"Gets the value of the attribute on the field in question from the dictionary as a string. If the attribute is a boolean attribute, use getBooleanAttribute(String) to get the value as a boolean rather than as a string","!type":"fn(attribute: string) -> string"},"getCurrencyDisplayValue":{"!doc":"Gets the currency display value","!type":"fn() -> string"},"getSessionCurrencyCode":{"!doc":"Gets the sessions currency ISO code","!type":"fn() -> string"},"getCurrencyValue":{"!doc":"Gets a currency value","!type":"fn() -> string"},"getReferenceCurrencyCode":{"!doc":"The currency ISO code, in the base system currency","!type":"fn() -> string"},"changesTo":{"!doc":"Determines if the new value of a field after a change matches a certain object","!type":"fn(value: ?) -> bool"},"getChoices":{"!doc":"Retrieves the choice list for a field","!type":"fn(dependent: string) -> []"},"getTableName":{"!doc":"Gets the table name","!type":"fn() -> string"},"hasAttribute":{"!doc":"Determines whether a field has a particular attribute","!type":"fn(attribute: string) -> bool"},"setDateNumericValue":{"!doc":"Sets a date to a numeric value","!type":"fn(value: ?)"},"setDisplayValue":{"!doc":"Sets the display value of the field","!type":"fn(value: ?)"},"getRefRecord":{"!doc":"Gets a GlideRecord object for a reference element","!type":"fn() -> +GlideRecord"},"canWrite":{"!doc":"Determines if the GlideRecord table can be written to","!type":"fn() -> bool"},"changesFrom":{"!doc":"Determines the previous value of the current field matched a certain object","!type":"fn(value: ?) -> bool"},"canCreate":{"!doc":"Determines if the user's role permits creation of new records in this field","!type":"fn() -> bool"},"getED":{"!doc":"Gets the field's element descriptor","!type":"fn() -> +GlideElementDescriptor"},"getSessionValue":{"!doc":"Gets the ammount in the sessions currency","!type":"fn() -> string"},"dateNumericValue":{"!doc":"Gets date in numberic value","!type":"fn(value: string) -> number"},"setError":{"!doc":"Adds an error message. Can be retrieved using getError()","!type":"fn(message: string)"},"setValue":{"!doc":"Sets the display value of the field","!type":"fn(value: ?)"},"getDisplayValue":{"!doc":"Gets the formatted display value of the field","!type":"fn(maxCharacters: number) -> string"},"toString":{"!doc":"Converts the value to a string","!type":"fn() -> string"}}},"GlideDateTime":{"!doc":"The scoped GlideDateTime default constructor, instantiates a new GlideDateTime object with the current date and time in Greenwich Mean Time (GMT). Optional 'value' parameter with a date and time value in the UTC time zone specified with the format yyyy-MM-dd HH:mm:ss","!type":"fn(value: string)","prototype":{"getDayOfWeekLocalTime":{"!doc":"Gets the day of the week stored by the GlideDateTime object, expressed in the user's time zone","!type":"fn() -> number"},"before":{"!doc":"Returns true if the object's data time is before the input argument","!type":"fn(object: +GlideDateTime) -> bool"},"addWeeksUTC":{"!doc":"Adds a specified number of weeks to the current GlideDateTime object, expressed in the UTC time zone","!type":"fn(amount: number)"},"getDaysInMonthLocalTime":{"!doc":"Sets the day of the month to a specified value in the user's time zone","!type":"fn() -> number"},"setMonthUTC":{"!doc":"Sets the month stored by the GlideDateTime object to a specified value using the UTC time zone","!type":"fn(month: number)"},"compareTo":{"!doc":"Compares two GlideDateTime objects","!type":"fn(object: +GlideDateTime) -> number"},"setGlideDateTime":{"!doc":"Sets the date and time of the current object using an existing GlideDateTime object. This method is equivalent to instantiating a new object with a GlideDateTime parameter","!type":"fn(gdt: +GlideDateTime)"},"setMonthLocalTime":{"!doc":"Sets the month stored by the GlideDateTime object to a specified value using the current user's time zone","!type":"fn(month: number)"},"getMonthLocalTime":{"!doc":"Gets the month stored by the GlideDateTime object, expressed in the current user's time zone","!type":"fn() -> number"},"getLocalDate":{"!doc":"Gets the date for the user's time zone","!type":"fn() -> +GlideDate"},"setYearUTC":{"!doc":"Sets the year stored by the GlideDateTime object to a specified value using the UTC time zone","!type":"fn(year: number)"},"getDayOfWeekUTC":{"!doc":"Gets the day of the week stored by the GlideDateTime object, expressed in the UTC time zone","!type":"fn() -> number"},"getWeekOfYearUTC":{"!doc":"Gets the number of the current week of the current year","!type":"fn() -> number"},"setDayOfMonthLocalTime":{"!doc":"Sets the day of the month to a specified value in the local time zone","!type":"fn(day: number)"},"addYearsUTC":{"!doc":"Adds a specified number of years to the current GlideDateTime object, expressed in the UTC time zone","!type":"fn(amount: number)"},"onOrAfter":{"!doc":"Returns true if the object's data time is on or after the input argument","!type":"fn(object: +GlideDateTime) -> bool"},"add":{"!doc":"Adds a GlideTime object to the current GlideDateTime object","!type":"fn(gt: +GlideTime)"},"getInternalFormattedLocalTime":{"!doc":"Returns local time with internal time format","!type":"fn() -> string"},"subtract":{"!doc":"Gets the duration difference between two GlideDateTime values. Pass a single paramter which specifies milliseconds to subtract from the current GlideDateTime object","!type":"fn(start: +GlideDateTime, end: +GlideDateTime) -> +GlideDuration"},"getWeekOfYearLocalTime":{"!doc":"Gets the number of the week stored by the GlideDateTime object, expressed in the user's time zone","!type":"fn() -> number"},"getDisplayValueWithoutTZ":{"!doc":"","!type":"fn() -> string"},"setDisplayValue":{"!doc":"Sets a date and time value using the current user's display format and time zone. Also set an optional parameter 'format', to set date and time format","!type":"fn(value: string, format: string)"},"getUserFormattedLocalTime":{"!doc":"Returns local time with user time format","!type":"fn() -> string"},"getMonthUTC":{"!doc":"Gets the month stored by the GlideDateTime object, expressed in the UTC time zone","!type":"fn() -> number"},"addSeconds":{"!doc":"Adds a specified number of seconds to the current GlideDateTime object","!type":"fn(value: number)"},"getDaysInMonthUTC":{"!doc":"Gets the number of days in the month stored by the GlideDateTime object, expressed in the UTC time zone","!type":"fn() -> number"},"getLocalTime":{"!doc":"Returns a GlideTime object that represents the time portion of the GlideDateTime object in the user's time zone","!type":"fn() -> +GlideTime"},"addYearsLocalTime":{"!doc":"Adds a specified number of years to the current GlideDateTime object, expressed in the user's time zone","!type":"fn(amount: number)"},"getYearLocalTime":{"!doc":"Gets the year stored by the GlideDateTime object, expressed in the current user's time zone","!type":"fn() -> number"},"getDayOfMonthUTC":{"!doc":"Gets the day of the month stored by the GlideDateTime object, expressed in the UTC time zone","!type":"fn() -> number"},"getNumericValue":{"!doc":"Gets the number of milliseconds since January 1, 1970, 00:00:00 Greenwich Mean Time (GMT)","!type":"fn() -> number"},"getTime":{"!doc":"Returns a GlideTime object that represents the time portion of the GlideDateTime object","!type":"fn() -> +GlideTime"},"isDST":{"!doc":"Determines if an object's time uses a daylight savings offset","!type":"fn() -> bool"},"addMonthsUTC":{"!doc":"Adds a specified number of months to the current GlideDateTime object, expressed in the UTC time zone","!type":"fn(amount: number)"},"addDaysLocalTime":{"!doc":"Adds a specified number of days to the current GlideDateTime object, expressed in the user's timezone","!type":"fn(amount: number)"},"getDSTOffset":{"!doc":"Gets the amount of time that daylight savings time is offset","!type":"fn() -> number"},"hashCode":{"!doc":"","!type":"fn() -> number"},"addMonthsLocalTime":{"!doc":"Adds a specified number of months to the current GlideDateTime object, expressed in the user's time zone","!type":"fn(amount: number)"},"getDisplayValueInternal":{"!doc":"Gets the display value in the internal datetime format","!type":"fn() -> string"},"getDayOfMonthLocalTime":{"!doc":"Gets the day of the month stored by the GlideDateTime object, expressed in the current user's time zone","!type":"fn() -> number"},"getDate":{"!doc":"Gets the date in the system time zone","!type":"fn() -> +GlideDate"},"after":{"!doc":"Returns true if the object's data time is after the input argument","!type":"fn(object: +GlideDateTime) -> bool"},"getErrorMsg":{"!doc":"Gets the current error message","!type":"fn() -> string"},"getTZOffset":{"!doc":"","!type":"fn() -> number"},"setDisplayValueInternal":{"!doc":"Sets a date and time value using the internal format and the current user's time zone","!type":"fn(value: string)"},"onOrBefore":{"!doc":"Returns true if the object's data time is on or before the input argument","!type":"fn(object: +GlideDateTime) -> bool"},"setDayOfMonthUTC":{"!doc":"Sets the day of the month to a specified value in the UTC time zone","!type":"fn(day: number)"},"isValid":{"!doc":"Determines if a value is a valid datetime","!type":"fn() -> bool"},"hasDate":{"!doc":"Determines if an object's date is set","!type":"fn() -> bool"},"setYearLocalTime":{"!doc":"Sets the year stored by the GlideDateTime object to a specified value using the current user's time zone","!type":"fn(year: number)"},"setValueUTC":{"!doc":"Sets a date and time value using the UTC time zone and the specified date and time format","!type":"fn(dt: string, format: string)"},"getValue":{"!doc":"Gets a datetiime value in the same format as it is stored in the database","!type":"fn() -> string"},"getYearUTC":{"!doc":"Gets the year stored by the GlideDateTime object, expressed in the UTC time zone","!type":"fn() -> number"},"equals":{"!doc":"","!type":"fn(object: +GlideDateTime) -> bool"},"getDisplayValue":{"!doc":"Gets the datetime in the current user's display format and time zone","!type":"fn() -> string"},"setValue":{"!doc":"Sets the date and time","!type":"fn(value: number)"},"toString":{"!doc":"Converts a datetime value to a string","!type":"fn() -> string"},"addDaysUTC":{"!doc":"Adds a specified number of days to the current GlideDateTime object, expressed in the UTC time zone","!type":"fn(amount: number)"},"addWeeksLocalTime":{"!doc":"Adds a specified number of weeks to the current GlideDateTime object, expressed in the user's timezone","!type":"fn(amount: number)"}}},"GlideDBFunctionBuilder":{"!doc":"The Scoped GlideDBFunctionBuilder provides a builder API for creating platform function definition","!type":"fn()","prototype":{"add":{"!doc":"Start an addition function","!type":"fn() -> +GlideDBFunctionBuilder"},"constant":{"!doc":"Add a constant parameter to the current function","!type":"fn(constant: string) -> +GlideDBFunctionBuilder"},"endfunc":{"!doc":"End the current function","!type":"fn() -> +GlideDBFunctionBuilder"},"subtract":{"!doc":"Start a subtraction function","!type":"fn() -> +GlideDBFunctionBuilder"},"length":{"!doc":"Start a length function","!type":"fn() -> +GlideDBFunctionBuilder"},"concat":{"!doc":"Start a concatenation function","!type":"fn() -> +GlideDBFunctionBuilder"},"datediff":{"!doc":"Start a function that return the duration between 2 dates","!type":"fn() -> +GlideDBFunctionBuilder"},"field":{"!doc":"Add a field parameter to the current function","!type":"fn(fieldName: string) -> +GlideDBFunctionBuilder"},"build":{"!doc":"Return the completed function definition","!type":"fn() -> string"},"now":{"!doc":"Start a function that returns the current timestamp in the UTC timezone. This function should be used as a parameter to the datediff function to calculate a duration between the current datetime and another datetime field or datetime constant","!type":"fn() -> +GlideDBFunctionBuilder"},"dayofweek":{"!doc":"Start a function that returns the day of the week of a given date","!type":"fn() -> +GlideDBFunctionBuilder"},"divide":{"!doc":"Start a division function","!type":"fn() -> +GlideDBFunctionBuilder"},"multiply":{"!doc":"Start a multiplication function","!type":"fn() -> +GlideDBFunctionBuilder"}}},"sn_clotho":{"":{"prototype":{}},"TransformResult":{"!doc":"An object that contains a transform execution result","!type":"fn()","prototype":{"getByLabel":{"!doc":"Returns a series with the specified label","!type":"fn(label: string) -> +sn_clotho.Data"},"byGroup":{"!doc":"Returns a mapping of group names to their series","!type":"fn() -> +map"},"toArray":{"!doc":"Returns the all series of this TransformResult in the form of an array","!type":"fn() -> [+sn_clotho.Data]"},"getData":{"!doc":"Returns this result's series, assuming that there is a single resultant series","!type":"fn() -> +sn_clotho.Data"}}},"Transformer":{"!doc":"Instantiates a MetricBase transformer for the specified GlideRecord","!type":"fn(gr: +GlideRecord)","prototype":{"metric":{"!doc":"Specifies the metric field that this transformer operates on","!type":"fn(metricName: string) -> +sn_clotho.TransformPart"},"groupBy":{"!doc":"Groups the subject records by the specified field","!type":"fn(field: string) -> +sn_clotho.TransformPart"},"execute":{"!doc":"Executes the transforms defined by this transformer over the specified time range and returns an object containing the results","!type":"fn(rangeStart: +GlideDateTime, rangeEnd: +GlideDateTime) -> +sn_clotho.TransformResult"}}},"DataBuilder":{"!doc":"Builds data to put into MetricBase","!type":"fn(cx: Context, args: [object], ctorObj: Function, inNewExpr: boolean)","prototype":{"add":{"!doc":"Adds the specified value to the data at the specified time","!type":"fn(start: +GlideDateTime, value: number) -> +sn_clotho.DataBuilder"}}},"!doc":"MetricBase JavaScript API","TransformPart":{"!doc":"Defines a transformer's transforms","!type":"fn()","prototype":{"sub":{"!doc":"Subtracts the specified constant quantity from all values","!type":"fn(substrahend: number) -> +sn_clotho.TransformPart"},"mul":{"!doc":"Multiplies all values by the specified constant quantity","!type":"fn(factor: number) -> +sn_clotho.TransformPart"},"log":{"!doc":"Performs a logarithm on all values with the specified constant base","!type":"fn(base: number) -> +sn_clotho.TransformPart"},"sum":{"!doc":"Produces a new series where each value is the sum of all of the values at each timestamp","!type":"fn() -> +sn_clotho.TransformPart"},"groupBy":{"!doc":"Groups the subject records by the specified field","!type":"fn(field: string) -> +sn_clotho.TransformPart"},"div":{"!doc":"Divides all values by the specified constant quantity","!type":"fn(divisor: number) -> +sn_clotho.TransformPart"},"fit":{"!doc":"Fits the series to the specified model using the specified parameters","!type":"fn(_params: object) -> +sn_clotho.TransformPart"},"avg":{"!doc":"Produces a new series where each value is the average of all of the values at each timestamp","!type":"fn() -> +sn_clotho.TransformPart"},"min":{"!doc":"Produces a new series with the smallest values at each timestamp","!type":"fn() -> +sn_clotho.TransformPart"},"partition":{"!doc":"Produces a new series with the values filtered (AVG, MAX, MIN or LAST) by non-overlapping windows","!type":"fn(_aggregator: string, _window: string, _base: string) -> +sn_clotho.TransformPart"},"top":{"!doc":"Produces a set of series with the top 'count' (specified) largest values at each timestamp","!type":"fn(count: number) -> +sn_clotho.TransformPart"},"limit":{"!doc":"Limits the number of data points in each series to the specified count","!type":"fn(count: number) -> +sn_clotho.TransformPart"},"where":{"!doc":"Produces a set of new series by specified condition","!type":"fn(condition: Condition) -> +sn_clotho.TransformPart"},"stddev":{"!doc":"Produces a new series with the standard deviation of the values at each timestamp","!type":"fn() -> +sn_clotho.TransformPart"},"floor":{"!doc":"Floors all values to the specified precision","!type":"fn(precision: number) -> +sn_clotho.TransformPart"},"fractiles":{"!doc":"Produces a set of series where each is one of the specified percentiles of all of the data","!type":"fn(fractions: [number]) -> +sn_clotho.TransformPart"},"add":{"!doc":"Adds the specified constant quantity to all values","!type":"fn(summand: number) -> +sn_clotho.TransformPart"},"max":{"!doc":"Produces a new series with the largest values at each timestamp","!type":"fn() -> +sn_clotho.TransformPart"},"bottom":{"!doc":"Produces a set of series with the bottom 'count' (specified) smallest values at each timestamp","!type":"fn(count: number) -> +sn_clotho.TransformPart"},"count":{"!doc":"Produces a new series that counts the number of series with values in the input","!type":"fn() -> +sn_clotho.TransformPart"},"interpolate":{"!doc":"Populates missing (NaN) values with two-point linear regression using the specified tolerance for maximum range of missing data","!type":"fn(countOrDuration: object) -> +sn_clotho.TransformPart"},"label":{"!doc":"Labels this series","!type":"fn(label: string) -> +sn_clotho.TransformPart"},"ceil":{"!doc":"Ceils all values to the specified precision","!type":"fn(precision: number) -> +sn_clotho.TransformPart"},"filter":{"!doc":"Produces a new series with the values filtered (AVG, MAX, MIN or LAST) by sliding windows","!type":"fn(_aggregator: string, _window: string) -> +sn_clotho.TransformPart"},"median":{"!doc":"Produces a new series with the median of the values at each timestamp","!type":"fn() -> +sn_clotho.TransformPart"},"round":{"!doc":"Rounds all values to the specified precision","!type":"fn(precision: number) -> +sn_clotho.TransformPart"},"metric":{"!doc":"Specifies the metric field that this transformer operates on","!type":"fn(metricName: string) -> +sn_clotho.TransformPart"},"collect":{"!doc":"Includes this intermediate transform as part of the result","!type":"fn() -> +sn_clotho.TransformPart"},"resample":{"!doc":"Aligns all series to have the specified number of data points","!type":"fn(numValues: number) -> +sn_clotho.TransformPart"}}},"Data":{"!doc":"Stores a single series of MetricBase data","!type":"fn()","prototype":{"getSubject":{"!doc":"Returns the value of the subject this series operates on","!type":"fn() -> string"},"fromModelString":{"!doc":"Converts the specified model string into a series","!type":"fn(model: string) -> +sn_clotho.Data"},"getLabel":{"!doc":"Returns the label of this series","!type":"fn() -> string"},"getStart":{"!doc":"Returns the start time of this series","!type":"fn() -> +GlideDateTime"},"size":{"!doc":"Returns the number of values in this series","!type":"fn() -> number"},"getValues":{"!doc":"Returns the values in this series in the form of an array of numbers","!type":"fn() -> [number]"},"getTableName":{"!doc":"Returns the name of the table this series operates on","!type":"fn() -> string"},"getMetricName":{"!doc":"Returns the name of the metric this series operates on","!type":"fn() -> string"},"toModelString":{"!doc":"Converts this series into a model string","!type":"fn() -> string"},"getEnd":{"!doc":"Returns the end time of this series","!type":"fn() -> +GlideDateTime"},"getPeriod":{"!doc":"Returns the period of this series","!type":"fn() -> number"}}},"Client":{"!doc":"Interacts with the MetricBase database","!type":"fn()","prototype":{"transform":{"!doc":"Performs the specified transform(s) over the specified range","!type":"fn(o1: object, o2: +GlideDateTime, o3: +GlideDateTime) -> object"},"put":{"!doc":"Uses the specified DataBuilder to put data into MetricBase","!type":"fn(dataBuilder: +sn_clotho.DataBuilder)"}}}},"GlideLocale":{"!doc":"GlideLocale is a global object that can be called in scripts. Use the get() method to get a GlideLocale object","get":{"!doc":"Returns the GlideLocale object","!type":"fn() -> +GlideLocale"},"!type":"fn()","prototype":{"getGroupingSeparator":{"!doc":"Returns the decimal separator","!type":"fn() -> string"},"getDecimalSeparator":{"!doc":"Returns the grouping separator","!type":"fn() -> string"}}},"XMLNodeIterator":{"!doc":"The scoped XMLNodeIterator class allows you to iterate through a node of a XML document","!type":"fn()","prototype":{"next":{"!doc":"Gets the next element in the iteration","!type":"fn() -> +XMLNode"},"hasNext":{"!doc":"Determines if the iteration has more elements","!type":"fn() -> bool"}}}},"sys_script_email":{"GlideServletRequest":{"!doc":"ServiceNow processors are equivalent to Java servlets. Processors provide a customizable URL endpoint that can execute arbitrary server-side Javascript code and produce output such as TEXT, JSON, or HTML. The GlideServletRequest API is used in processor scripts to access the HttpServletRequest object. The GlideServletRequest object provides a subset of the HttpServletRequest APIs. The methods are called using the global variable g_request. A useful global variable, g_target, is available in processor scripts. It contains the table name extracted from the URL. The URL to a processor has the format: https://<instance name.servicenow.com>/<path endpoint>.do?<parameter endpoint>=<value> where the path endpoint and parameter endpoint are defined on the processor form","!type":"fn()","prototype":{"getHeaders":{"!doc":"Returns an array of headers as a string","!type":"fn(name: string) -> [string]"},"getHeaderNames":{"!doc":"Returns an array of header names as a string","!type":"fn() -> [string]"},"getQueryString":{"!doc":"Returns the query string from the request","!type":"fn() -> string"},"getContentType":{"!doc":"Returns the content type","!type":"fn() -> string"},"getParameterNames":{"!doc":"Returns an array of parameter names as a string","!type":"fn() -> [string]"},"getHeader":{"!doc":"Returns the header","!type":"fn(name: string) -> string"},"getParameter":{"!doc":"Returns an object","!type":"fn(name: string) -> ?"}}},"template":{"print":{"!doc":"Outputs message to the email body","!type":"fn(message: string)"},"!doc":"Handles printing from the mail script to the email message","space":{"!doc":"Outputs spaces to the email body","!type":"fn(spaces: number)"}},"email_action":{"message_list":{"!doc":"","!type":"+GlideElement"},"action_insert":{"!doc":"Send an email whenever a new record is inserted into the selected table","!type":"+GlideElement"},"action_update":{"!doc":"Send an email whenever a record in the selected table is modified","!type":"+GlideElement"},"subject":{"!doc":"","!type":"+GlideElement"},"digest_template":{"!doc":"","!type":"+GlideElement"},"sys_updated_on":{"!doc":"","!type":"+GlideElement"},"type":{"!doc":"","!type":"+GlideElement"},"item_table":{"!doc":"The table that the subscribed item resides in","!type":"+GlideElement"},"sys_updated_by":{"!doc":"","!type":"+GlideElement"},"reply_to":{"!doc":"Email address to be used when replying to the email notification","!type":"+GlideElement"},"digest_separator_html":{"!doc":"","!type":"+GlideElement"},"sys_created_on":{"!doc":"","!type":"+GlideElement"},"sys_domain":{"!doc":"Domain to which the rule belongs","!type":"+GlideElement"},"digest_separator_text":{"!doc":"","!type":"+GlideElement"},"sys_name":{"!doc":"Display name for this application file","!type":"+GlideElement"},"from":{"!doc":"Email address you want to appear in the From field","!type":"+GlideElement"},"sms_alternate":{"!doc":"","!type":"+GlideElement"},"exclude_delegates":{"!doc":"Do not send the notification to any delegates of this notification's recipients","!type":"+GlideElement"},"sys_created_by":{"!doc":"","!type":"+GlideElement"},"order":{"!doc":"","!type":"+GlideElement"},"recipient_groups":{"!doc":"List of groups that will receive an email notification","!type":"+GlideElement"},"recipient_users":{"!doc":"List of users or email addresses that will receive an email notification","!type":"+GlideElement"},"item":{"!doc":"The sys_id of the subscribed item","!type":"+GlideElement"},"active":{"!doc":"","!type":"+GlideElement"},"sys_overrides":{"!doc":"Rule being overridden by the current record","!type":"+GlideElement"},"weight":{"!doc":"Used to decide which notification takes precedence when more than one qualifies","!type":"+GlideElement"},"collection":{"!doc":"","!type":"+GlideElement"},"sys_domain_path":{"!doc":"","!type":"+GlideElement"},"generation_type":{"!doc":"Action that causes an email to be sent. Specifies whether to send email based on a trigger, an event firing, or an action against a record.","!type":"+GlideElement"},"message_html":{"!doc":"","!type":"+GlideElement"},"condition":{"!doc":"Send Notification when conditions evaluate to true","!type":"+GlideElement"},"message_text":{"!doc":"","!type":"+GlideElement"},"sys_update_name":{"!doc":"","!type":"+GlideElement"},"send_self":{"!doc":"","!type":"+GlideElement"},"name":{"!doc":"","!type":"+GlideElement"},"event_name":{"!doc":"","!type":"+GlideElement"},"style":{"!doc":"","!type":"+GlideElement"},"sys_policy":{"!doc":"Determines how application files are protected when downloaded or installed","!type":"+GlideElement"},"template":{"!doc":"","!type":"+GlideElement"},"digest_reply_to":{"!doc":"","!type":"+GlideElement"},"importance":{"!doc":"Importance\\/Priority flag for the email","!type":"+GlideElement"},"!proto":"+GlideRecord","description":{"!doc":"","!type":"+GlideElement"},"mandatory":{"!doc":"Prevent users from unsubscribing\\/filtering-out this notification","!type":"+GlideElement"},"sys_class_name":{"!doc":"","!type":"+GlideElement"},"sys_id":{"!doc":"","!type":"+GlideElement"},"sys_version":{"!doc":"Notification Version","!type":"+GlideElement"},"content_type":{"!doc":"Specify whether the message is sent with a format of HTML, plain text, or both","!type":"+GlideElement"},"omit_watermark":{"!doc":"Omitting watermark prevents any email replies from updating the triggering record","!type":"+GlideElement"},"digest_html":{"!doc":"","!type":"+GlideElement"},"sys_scope":{"!doc":"Application containing this record","!type":"+GlideElement"},"digest_from":{"!doc":"","!type":"+GlideElement"},"subscribable":{"!doc":"Allow users to choose this notification when subscribing to their messages","!type":"+GlideElement"},"include_attachments":{"!doc":"Send all attachments from the triggering record as email attachments ","!type":"+GlideElement"},"event_parm_2":{"!doc":"The second event parameter contains a recipient, either a user sys_id, group sys_id or an email address, who should receive this notification","!type":"+GlideElement"},"digestable":{"!doc":"","!type":"+GlideElement"},"default_interval":{"!doc":"","!type":"+GlideElement"},"event_parm_1":{"!doc":"The first event parameter contains a recipient, either a user sys_id, group sys_id or an email address, who should receive this notification","!type":"+GlideElement"},"force_delivery":{"!doc":"Bypass settings that would normally prevent sending to the recipient (e.g., device.schedule, user.notification)","!type":"+GlideElement"},"!doc":"Scoped GlideRecord is used for database operations instead of writing SQL queries. Provides data access APIs to retrieve, update, and delete records from a table","sys_mod_count":{"!doc":"","!type":"+GlideElement"},"digest_text":{"!doc":"","!type":"+GlideElement"},"message":{"!doc":"","!type":"+GlideElement"},"advanced_condition":{"!doc":"","!type":"+GlideElement"},"sys_package":{"!doc":"","!type":"+GlideElement"},"push_message_only":{"!doc":"","!type":"+GlideElement"},"recipient_fields":{"!doc":"Field in the currently-selected table that contains a reference to a user or group that will receive an email notification","!type":"+GlideElement"},"affected_field_on_event":{"!doc":"The field in the event that must be affected for this notification to send to subscribed users","!type":"+GlideElement"},"category":{"!doc":"The notification appears in the user notification preferences under the category provided. If no category is provided, it appears under 'Uncategorized'.","!type":"+GlideElement"},"digest_subject":{"!doc":"","!type":"+GlideElement"}},"XMLNode":{"!doc":"The scoped XMLNode API allows you to query values from XML nodes. XMLNodes are extracted from XMLDocument2 objects, which contain XML strings","!type":"fn()","prototype":{"getNodeValue":{"!doc":"Gets the node's value","!type":"fn() -> string"},"appendChild":{"!doc":"","!type":"fn(newChild: +XMLNode)"},"setAttribute":{"!doc":"","!type":"fn(attribute: string, value: string)"},"getChildNodeIterator":{"!doc":"Gets the node's XMLNodeIterator object","!type":"fn() -> +XMLNodeIterator"},"getAttribute":{"!doc":"Gets the value of the specified attribute","!type":"fn(attribute: string) -> string"},"hasAttribute":{"!doc":"Determines if the node has the specified attribute","!type":"fn(attribute: string) -> bool"},"getFirstChild":{"!doc":"Gets the node's first child node","!type":"fn() -> +XMLNode"},"toString":{"!doc":"Gets the node's string value","!type":"fn() -> string"},"getTextContent":{"!doc":"Gets the node's text content","!type":"fn() -> string"},"getNodeName":{"!doc":"Gets the node's name","!type":"fn() -> string"},"getLastChild":{"!doc":"Gets the node's last child node","!type":"fn() -> +XMLNode"}}},"GlideScopedEvaluator":{"!doc":"The API allows you to evaluate scripts from a GlideRecord field","!type":"fn()","prototype":{"evaluateScript":{"!doc":"Evaluates a script from a GlideRecord field. variables parameter is optional","!type":"fn(gr: +GlideRecord, scriptField: string, variables: ?) -> ?"},"putVariable":{"!doc":"Puts a variable into the GlideScopedEvaluator object","!type":"fn(name: string, value: ?)"},"getVariable":{"!doc":"Gets a variable from a GlideScopedEvaluator object","!type":"fn(name: string) -> ?"}}},"GlideTableHierarchy":{"!doc":"The Scoped GlideTableHierarchy API provides methods for handling information about table relationships","!type":"fn()","prototype":{"hasExtensions":{"!doc":"Returns true of this class has been extended","!type":"fn() -> bool"},"getName":{"!doc":"Returns the table's name","!type":"fn() -> string"},"isSoloClass":{"!doc":"Returns true if this table is not in a hierarchy","!type":"fn() -> bool"},"getTables":{"!doc":"Returns a list of the table names in the hierarchy","!type":"fn() -> []"},"getAllExtensions":{"!doc":"Returns a list of all tables that extend the current table and includes the current table","!type":"fn() -> []"},"isBaseClass":{"!doc":"Returns true if this is a base class","!type":"fn() -> bool"},"getTableExtensions":{"!doc":"Returns a list of all tables that extend the current table","!type":"fn() -> []"},"getBase":{"!doc":"Returns the parent class","!type":"fn() -> string"},"getRoot":{"!doc":"Returns the top level class in the hierarchy","!type":"fn() -> string"},"getHierarchy":{"!doc":"Returns a list of all classes in the hierarchy of the given table","!type":"fn() -> []"}}},"GlidePluginManager":{"!doc":"Scoped API for PluginManager","!type":"fn()","prototype":{"isActive":{"!doc":"Determine if a plugin is activated","!type":"fn(pluginID: string) -> bool"}}},"sn_auth":{"":{"prototype":{}},"GlideOAuthClient":{"!doc":"The OAuth client API provides methods to request and revoke OAuth tokens","!type":"fn()","prototype":{"revokeToken":{"!doc":"Revokes the access or refresh token for the client, with the request and optional header parameters set into a GlideOAuthClientRequest object","!type":"fn(clientName: string, accessToken: string, refreshToken: string, request: GlideOAuthClientRequest) -> +sn_auth.GlideOAuthClientResponse"},"requestTokenByRequest":{"!doc":"Retrieves the token for the client, with the request and optional header parameters set into a GlideOAuthClientRequest object","!type":"fn(clientName: string, request: GlideOAuthClientRequest) -> +sn_auth.GlideOAuthClientResponse"},"requestToken":{"!doc":"Retrieves the token for the client, with the request parameters encoded in JSON format","!type":"fn(clientName: string, jsonString: string) -> +sn_auth.GlideOAuthClientResponse"}}},"!doc":"Authentication API","GlideOAuthClientRequest":{"!doc":"Use these methods for handling client requests","!type":"fn()","prototype":{"getRefreshToken":{"!doc":"Retrieves the refresh token","!type":"fn() -> string"},"setPassword":{"!doc":"Sets the password with the string you provide","!type":"fn(password: string)"},"getHeaders":{"!doc":"Retrieves the HTTP headers","!type":"fn() -> ?"},"setHeader":{"!doc":"Sets the HTTP headers for the nave:value pair that you provide","!type":"fn(name: string, value: string)"},"getHeader":{"!doc":"Retrieves the HTTP headers for the string you provide","!type":"fn(name: string)"},"getPassword":{"!doc":"Retrieves the password","!type":"fn() -> string"},"setUserName":{"!doc":"Sets the user name with the string you provide","!type":"fn(userName: string)"},"setParameter":{"!doc":"Sets the parameters for the name:value pair of strings you provide","!type":"fn(name: string, value: string)"},"getGrantType":{"!doc":"Retrieves the grant type","!type":"fn()"},"setGrantType":{"!doc":"Sets the grant type with the string you provide","!type":"fn()"},"getUserName":{"!doc":"Retrieves the user name","!type":"fn() -> string"},"setScope":{"!doc":"Sets the scope with the string you provide","!type":"fn(scope: string)"},"setRefreshToken":{"!doc":"Sets the refresh token with the string you provide","!type":"fn(refreshToken: string)"},"getScope":{"!doc":"Retrieves the scope","!type":"fn() -> string"},"getParameter":{"!doc":"Retrieves the parameter for the parameter name you provide","!type":"fn(name: string)"}}},"GlideOAuthClientResponse":{"!doc":"","!type":"fn()","prototype":{"getResponseParameters":{"!doc":"Retrieves the response content from an external OAuth provider. The response is in a name:value pair","!type":"fn() -> ?"},"getBody":{"!doc":"Retrieves all of the response information, including instance information","!type":"fn() -> string"},"getToken":{"!doc":"Retrieves the refresh token","!type":"fn() -> +sn_auth.GlideOAuthToken"},"getResponseCode":{"!doc":"Retrieves the HTTP response code from the external OAuth provider","!type":"fn() -> string"},"getContentType":{"!doc":"Retrieves the HTTP response content header from an external OAuth provider","!type":"fn() -> string"},"getErrorMessage":{"!doc":"Retrieves the error message if authentication is not successful","!type":"fn() -> string"}}},"GlideOAuthToken":{"!doc":"Use these methods for retrieving the access token and information about the access token","!type":"fn()","prototype":{"getRefreshToken":{"!doc":"Retrieves the refresh token","!type":"fn() -> number"},"getRefreshTokenSysID":{"!doc":"Retrieves the sys_id of the refresh token","!type":"fn() -> string"},"getExpiresIn":{"!doc":"Retrieves the lifespan of the access token in seconds","!type":"fn() -> number"},"getAccessTokenSysID":{"!doc":"Retrieves the sys_id of the token ID","!type":"fn() -> string"},"getScope":{"!doc":"Retrieves the scope, which is the amount of access granted by the access token","!type":"fn() -> string"},"getAccessToken":{"!doc":"Retrieves the access token","!type":"fn() -> string"}}}},"GlideRecord":{"!doc":"Scoped GlideRecord is used for database operations instead of writing SQL queries. Provides data access APIs to retrieve, update, and delete records from a table","!type":"fn(tableName: string)","prototype":{"getLastErrorMessage":{"!doc":"Retrieves the last error message","!type":"fn() -> string"},"getLabel":{"!doc":"The label of the field as a String","!type":"fn() -> string"},"addJoinQuery":{"!doc":"Adds a filter to return records based on a relationship in a related table","!type":"fn(joinTable: string, primaryField: ?, joinTableField: ?) -> +GlideQueryCondition"},"setCategory":{"!doc":"","!type":"fn(category: string)"},"addActiveQuery":{"!doc":"Adds a filter to return active records","!type":"fn() -> +GlideQueryCondition"},"canDelete":{"!doc":"Determines if the Access Control Rules which include the user's roles permit deleting records in this table","!type":"fn() -> bool"},"setAbortAction":{"!doc":"Sets a flag to indicate if the next database action (insert, update, delete) is to be aborted","!type":"fn(b: bool)"},"getRowCount":{"!doc":"Retrieves the number of rows in the GlideRecord","!type":"fn() -> number"},"addFunction":{"!doc":"Retrieve the specified platform function in addition of the field values","!type":"fn(functionDefinition: string)"},"query":{"!doc":"Runs the query against the table based on the specified filters by addQuery and addEncodedQuery","!type":"fn()"},"getTableName":{"!doc":"Retrieves the table name associated with this GlideRecord","!type":"fn() -> string"},"getCategory":{"!doc":"","!type":"fn() -> string"},"orderByDesc":{"!doc":"Specifies a descending orderBy","!type":"fn(fieldName: string)"},"hasNext":{"!doc":"Determines if there are any more records in the GlideRecord","!type":"fn() -> bool"},"getClassDisplayValue":{"!doc":"","!type":"fn() -> string"},"isNewRecord":{"!doc":"Checks if the current record is a new record that has not yet been inserted into the database","!type":"fn() -> bool"},"getEncodedQuery":{"!doc":"Retrieves the query condition of the current result set as an encoded query string","!type":"fn() -> string"},"updateMultiple":{"!doc":"Updates each GlideRecord in the list with any changes that have been made","!type":"fn()"},"getRecordClassName":{"!doc":"Retrieves the class name for the current record","!type":"fn() -> string"},"autoSysFields":{"!doc":"","!type":"fn(b: bool)"},"getDisplayName":{"!doc":"Retrieves the name of the display field","!type":"fn() -> string"},"addQuery":{"!doc":"Adds a filter to return records by specifying a field and value. You can use an optional 'operator' as a second parameter","!type":"fn(name: string, value: string) -> +GlideQueryCondition"},"setLimit":{"!doc":"Sets the maximum number of records in the GlideRecord to be fetched in the next query","!type":"fn(limit: number)"},"getUniqueValue":{"!doc":"Gets the primary key of the record, which is usually the sys_id unless otherwise specified","!type":"fn() -> string"},"next":{"!doc":"Moves to the next record in the GlideRecord","!type":"fn() -> bool"},"deleteMultiple":{"!doc":"Deletes records that satisfy current query condition","!type":"fn()"},"canRead":{"!doc":"Determines if the Access Control Rules which include the user's roles permit reading records in this table","!type":"fn() -> bool"},"insert":{"!doc":"Insert a new record using the field values that have been set for the current record","!type":"fn() -> string"},"update":{"!doc":"Updates the current GlideRecord with any changes that have been made","!type":"fn(reason: ?) -> string"},"orderBy":{"!doc":"Specifies an orderBy column","!type":"fn(fieldName: string)"},"addNotNullQuery":{"!doc":"Adds a filter to return records where the specified field is not null","!type":"fn(fieldName: string) -> +GlideQueryCondition"},"addNullQuery":{"!doc":"Adds a filter to return records where the specified field is null","!type":"fn(fieldName: string) -> +GlideQueryCondition"},"addEncodedQuery":{"!doc":"Adds an encoded query to the other queries that may have been set","!type":"fn(query: string)"},"getAttribute":{"!doc":"Gets the attributes on the field in question from the dictionary","!type":"fn(attribute: string) -> string"},"get":{"!doc":"Defines a GlideRecord based on the specified expression of name = value","!type":"fn(name: ?, value: ?) -> bool"},"isValidRecord":{"!doc":"Determines if current record is a valid record","!type":"fn() -> bool"},"setNewGuidValue":{"!doc":"Sets sys_id value for the current record","!type":"fn(guid: string)"},"isValid":{"!doc":"Determines whether the table exists or not","!type":"fn() -> bool"},"isActionAborted":{"!doc":"Determines whether the current database action is to be aborted. Available in Fuji patch 3","!type":"fn() -> bool"},"chooseWindow":{"!doc":"Sets a range of rows to be returned by subsequent queries. If forceCount is true, getRowCount() method will return all possible records","!type":"fn(firstRow: number, lastRow: number, forceCount: bool)"},"canWrite":{"!doc":"Determines if the Access Control Rules which include the user's roles permit editing records in this table","!type":"fn() -> bool"},"setTextSearchOpts":{"!doc":"Provide additional options for text search query","!type":"fn(textSearchOpts: ?)"},"canCreate":{"!doc":"Determines if the Access Control Rules which include the user's roles permit inserting new records in this table","!type":"fn() -> bool"},"setWorkflow":{"!doc":"Enables and disables the running of business rules and script engines. When disabled, inserts and updates are not audited","!type":"fn(e: bool)"},"getValue":{"!doc":"Retrieves the underlying value of a field","!type":"fn(fieldName: string) -> string"},"getLink":{"!doc":"Retrieves a link to the current record","!type":"fn(nostack: bool) -> string"},"getElement":{"!doc":"Retrieves the GlideElement for a specified field","!type":"fn(fieldName: string) -> +GlideElement"},"setValue":{"!doc":"Sets the value for the specified field.","!type":"fn(fieldName: string, value: ?)"},"getDisplayValue":{"!doc":"Retrieves the display value for the current record","!type":"fn(fieldName: string) -> string"},"isValidField":{"!doc":"Determines if the given field is defined in the current table","!type":"fn(fieldName: string) -> bool"},"initialize":{"!doc":"Creates an empty record suitable for population before an insert","!type":"fn()"},"operation":{"!doc":"Retrieves the current operation being performed, such as insert, update, or delete","!type":"fn() -> string"},"newRecord":{"!doc":"Creates a new GlideRecord, sets the default values for the fields, and assigns a unique ID to the record","!type":"fn()"},"deleteRecord":{"!doc":"Deletes the current record","!type":"fn() -> bool"}}},"sn_ws":{"":{"prototype":{}},"RESTResponseV2":{"!doc":"The RESTResponseV2 API allows you to use the data returned by an outbound REST message in JavaScript code. A RESTResponseV2 object is returned by the RESTMessageV2 functions execute() and executeAsync()","!type":"fn()","prototype":{"getStatusCode":{"!doc":"Get the numeric HTTP status code returned by the REST provider","!type":"fn(name: string) -> number"},"getHeaders":{"!doc":"Deprecated -- use getAllHeaders instead","!type":"fn() -> Object"},"waitForResponse":{"!doc":"Set the amount of time the instance waits for the response","!type":"fn(timeoutSecs: number)"},"getBody":{"!doc":"Get the content of the REST response body","!type":"fn() -> string"},"getErrorCode":{"!doc":"Get the numeric error code, if there was an error during the REST transaction","!type":"fn() -> number"},"getQueryString":{"!doc":"Get the error message if there was an error during the REST transaction","!type":"fn() -> string"},"getAllHeaders":{"!doc":"Get all headers returned in the REST response and the associated values","!type":"fn() -> [+GlideHTTPHeader]"},"haveError":{"!doc":"Indicate if there was an error during the REST transaction","!type":"fn() -> bool"},"getHeader":{"!doc":"Get the value for a specified header","!type":"fn(name: string) -> string"},"getErrorMessage":{"!doc":"Get the query used for this request","!type":"fn() -> string"}}},"!doc":"Web Services API, to send a message to a web service provider","SOAPMessageV2":{"!doc":"Instantiates a SOAPMessageV2 object. Specify optional message and a function if there is a SOAP message record","!type":"fn(soapMessage: string, soapFunction: string)","prototype":{"setMIDServer":{"!doc":"Configure the SOAP message to be sent through a MID Server","!type":"fn(midServerName: string)"},"getRequestBody":{"!doc":"Get the content of the SOAP message body","!type":"fn() -> string"},"getRequestHeader":{"!doc":"Get the value for an HTTP header specified by the SOAP client","!type":"fn(headerName: string) -> string"},"setBasicAuth":{"!doc":"Set basic authentication headers for the SOAP message","!type":"fn(userName: string, userPass: string)"},"setWSSecurityUsernameToken":{"!doc":"Set WS-Security Username token","!type":"fn(username: string, password: string)"},"setRequestHeader":{"!doc":"Set an HTTP header in the SOAP message to the specified value","!type":"fn(headerName: string, headerValue: string)"},"getEndpoint":{"!doc":"Get the URL of the endpoint for the SOAP message","!type":"fn() -> string"},"setWSSecurityX509Token":{"!doc":"Set WS-Security X.509 token","!type":"fn(keystoreId: string, keystoreAlias: string, keystorePassword: string, certificateId: string)"},"setStringParameterNoEscape":{"!doc":"Set a variable from the SOAP message record to the specified value without escaping XML reserved characters","!type":"fn(name: string, value: string)"},"execute":{"!doc":"Send the SOAP Message to the endpoint","!type":"fn() -> +sn_ws.SOAPResponse"},"setHttpTimeout":{"!doc":"Set the amount of time the request waits for a response from the web service provider before the request times out","!type":"fn(timeoutMs: number)"},"setEndpoint":{"!doc":"Set the endpoint for the SOAP message","!type":"fn(endpoint: string)"},"setRequestBody":{"!doc":"Set the body content to send to the web service provider","!type":"fn(requestBody: string)"},"getRequestHeaders":{"!doc":"Get name and value for all HTTP headers specified by the SOAP client","!type":"fn() -> Object"},"setStringParameter":{"!doc":"Set a variable from the SOAP message record to the specified value","!type":"fn(name: string, value: string)"},"setSOAPAction":{"!doc":"Define the SOAP action this SOAP message performs","!type":"fn(soapAction: string)"},"setMutualAuth":{"!doc":"Set the mutual authentication protocol profile for the SOAP message","!type":"fn(profileName: string)"},"setEccCorrelator":{"!doc":"Associate outbound requests and the resulting response record in the ECC queue","!type":"fn(correlator: string)"},"setWSSecurity":{"!doc":"Set web service security values for the SOAP message","!type":"fn(keystoreId: string, keystoreAlias: string, keystorePassword: string, certificateId: string)"},"setEccParameter":{"!doc":"Override a value from the database by writing to the SOAP message payload","!type":"fn(name: string, value: string)"},"executeAsync":{"!doc":"Send the SOAP Message to the endpoint asynchronously","!type":"fn() -> +sn_ws.SOAPResponse"}}},"SOAPResponseV2":{"!doc":"The SOAPResponseV2 API allows you to use the data returned by an outbound SOAP message in JavaScript code. A SOAPResponseV2 object is returned by the SOAPMessageV2 functions execute() and executeAsync()","!type":"fn()","prototype":{"getStatusCode":{"!doc":"Get the numeric HTTP status code returned by the SOAP provider","!type":"fn() -> number"},"getHeaders":{"!doc":"Deprecated -- use getAllHeaders instead","!type":"fn() -> Object"},"waitForResponse":{"!doc":"Set the amount of time the instance waits for a response","!type":"fn(timeoutSecs: number)"},"getBody":{"!doc":"Get the content of the SOAP response body","!type":"fn() -> string"},"getErrorCode":{"!doc":"Get the numeric error code if there was an error during the SOAP transaction","!type":"fn() -> number"},"getAllHeaders":{"!doc":"Get all HTTP headers returned in the SOAP response and the associated values","!type":"fn() -> [+GlideHTTPHeader]"},"haveError":{"!doc":"Indicate if there was an error during the SOAP transaction","!type":"fn() -> bool"},"getHeader":{"!doc":"Get the value for a specified HTTP header","!type":"fn(name: string)-> string"},"getErrorMessage":{"!doc":"Get the error message if there was an error during the SOAP transaction","!type":"fn() -> string"}}},"RESTMessageV2":{"!doc":"Instantiates a RESTMessageV2 object. When you have a REST message record, you can add the optional name and methodName information","!type":"fn(name: string, methodName: string)","prototype":{"setMIDServer":{"!doc":"Configure the REST message to communicate through a MID Server","!type":"fn(midServer: string)"},"getRequestBody":{"!doc":"Get the content of the REST message body","!type":"fn() -> string"},"getRequestHeader":{"!doc":"Get the value for an HTTP header specified by the REST client","!type":"fn(headerName: string) -> string"},"setHttpMethod":{"!doc":"The HTTP method this REST message performs, such as GET or PUT. You must set an HTTP method when using the RESTMessageV2() constructor with no parameters","!type":"fn(method: string)"},"setBasicAuth":{"!doc":"Set basic authentication headers for the REST message","!type":"fn(userName: string, userPass: string)"},"setRequestHeader":{"!doc":"Set an HTTP header to the specified value","!type":"fn(name: string, value: string)"},"setAuthenticationProfile":{"!doc":"Set the credentials for the REST message using an existing basic auth or OAuth 2.0 profile. Valid types are 'basic' and 'oauth2'. Valid profileIds are the sys_id of a Basic Auth Configuration [sys_auth_profile_basic] record or an OAuth Entity Profile [oauth_entity_profile] record","!type":"fn(type: string, profileId: string)"},"setQueryParameter":{"!doc":"Append a name-value parameter to the request URL","!type":"fn(name: string, value: string)"},"setRequestBodyFromAttachment":{"!doc":"Uses the specified attachment as the request body of this REST Message. Mutually exclusive with setRequestBody","!type":"fn(attachmentSysId: string)"},"getEndpoint":{"!doc":"Get the URL of the endpoint for the REST message","!type":"fn() -> string"},"setStringParameterNoEscape":{"!doc":"Set a REST message function variable to the specified value without escaping XML reserved characters","!type":"fn(name: string, value: string)"},"execute":{"!doc":"Send the REST message to the endpoint","!type":"fn() -> +sn_ws.RESTResponseV2"},"setHttpTimeout":{"!doc":"Set the amount of time the REST message waits for a response from the REST provider","!type":"fn(timeoutMs: number)"},"setEndpoint":{"!doc":"Set the endpoint for the REST message","!type":"fn(endpoint: string)"},"setRequestBody":{"!doc":"Set the body content of a PUT or POST request. Mutually exclusive with setRequestBodyFromAttachment","!type":"fn(body: string)"},"getRequestHeaders":{"!doc":"Get name and value for all HTTP headers specified by the REST client","!type":"fn() -> Object"},"saveResponseBodyAsAttachment":{"!doc":"Setup the response body to be saved into the specified attachment when the request is sent. encryptCtxSysId is optional","!type":"fn(tableName: string, recordSysId: string, filename: string, encryptCtxSysId: string)"},"setStringParameter":{"!doc":"Set a REST message function variable to the specified value","!type":"fn(name: string, value: string)"},"setMutualAuth":{"!doc":"Set the mutual authentication protocol profile for the REST message","!type":"fn(profileName: string)"},"setEccTopic":{"!doc":"Set the ECC topic for the REST message. The default ECC topic is RESTProbe if topic is not set. In most cases it is unnecessary to set ECC topic","!type":"fn(topic: string)"},"setEccCorrelator":{"!doc":"Associate outbound requests and the resulting response record in the ECC queue","!type":"fn(correlator: string)"},"setEccParameter":{"!doc":"Override a value from the database by writing to the REST message payload","!type":"fn(name: string, value: string)"},"executeAsync":{"!doc":"Send the REST message to the endpoint asynchronously. The instance does not wait for a response from the web service provider when making asynchronous calls","!type":"fn() -> +sn_ws.RESTResponseV2"},"getEccTopic":{"!doc":"Get the ECC topic for the REST message","!type":"fn() -> string"}}}},"GlideServletResponse":{"!doc":"ServiceNow processors are equivalent to Java servlets. Processors provide a customizable URL endpoint that can execute arbitrary server-side Javascript code and produce output such as TEXT, JSON, or HTML. The GlideServletResponse API is used in processor scripts to access the HttpServletResponse object. The GlideServletResponse object provides a subset of the HttpServletResponse APIs. The methods are called using the global variable g_response. A useful global variable, g_target, is available in processor scripts. It contains the table name extracted from the URL. The URL to a processor has the format: https://<instance name.servicenow.com>/<path endpoint>.do?<parameter endpoint>=<value> where the path endpoint and parameter endpoint are defined on the processor form","!type":"fn()","prototype":{"setContentType":{"!doc":"Sets the MIME type of the response","!type":"fn(type: string)"},"sendRedirect":{"!doc":"Sends a temporary redirect to the client","!type":"fn(location: string)"},"setStatus":{"!doc":"Sets the status code for the response","!type":"fn(status: number)"},"setHeader":{"!doc":"Sets a response header to the specified value","!type":"fn(key: string, value: string)"}}},"GlideElementDescriptor":{"!doc":"The scoped GlideElementDescriptor class provides information about individual fields","!type":"fn()","prototype":{"getName":{"!doc":"Returns the field's name","!type":"fn() -> string"},"getInternalType":{"!doc":"Returns the field's data type","!type":"fn() -> string"},"getLabel":{"!doc":"Returns the field's label","!type":"fn() -> string"},"getLength":{"!doc":"Returns the field's length","!type":"fn() -> number"}}},"GlideQueryCondition":{"!doc":"The scoped QueryCondition API provides additional AND or OR conditions that can be added to the current condition, allowing you to build complex queries such as: category='hardware' OR category='software' AND priority='2' AND priority='1'","!type":"fn()","prototype":{"addOrCondition":{"!doc":"Adds an OR condition to the current condition. oper is an optional parameter","!type":"fn(name: string, oper: string, value: ?) -> +GlideQueryCondition"},"addCondition":{"!doc":"Adds an AND condition to the current condition. oper is an optional parameter","!type":"fn(name: string, oper: string, value: ?) -> +GlideQueryCondition"}}},"GlideScriptableInputStream":{"!doc":"A wrapper around an InputStream. No functions are provided to manipulate the stream from script. Rather this object can be passed to any API which takes an InputStream as an input parameter","!type":"fn()"},"GlideRecordSecure":{"!doc":"GlideRecordSecure is a class inherited from GlideRecord that performs the same functions as GlideRecord, and also enforces ACLs","!type":"GlideRecord"},"current":{"!doc":"Scoped GlideRecord is used for database operations instead of writing SQL queries. Provides data access APIs to retrieve, update, and delete records from a table","!proto":"+GlideRecord"},"XMLDocument2":{"!doc":"XMLDocument2 is a JavaScript Object wrapper for parsing and extracting XML data from an XML string. Use this JavaScript class to instantiate an object from an XML string, usually a return value from a Web Service invocation, or the XML payload of ECC Queue","!type":"fn()","prototype":{"getFirstNode":{"!doc":"Gets the first node in the specified xpath","!type":"fn(xpath: string) -> +XMLNode"},"createElementWithTextValue":{"!doc":"Creates an element node with a text child node and adds it to the current node","!type":"fn(name: string, value: string) -> +XMLNode"},"getNextNode":{"!doc":"Gets the node after the specified node","!type":"fn(prev: +XMLNode) -> +XMLNode"},"isValid":{"!doc":"Checks if the XMLDocument is valid","!type":"fn() -> bool"},"setCurrentElement":{"!doc":"Makes the node passed in as a parameter the current node","!type":"fn(element: +XMLNode)"},"getDocumentElement":{"!doc":"Gets the document element node of the XMLDocument2. The document element node is the root node","!type":"fn() -> +XMLNode"},"parseXML":{"!doc":"Parses the XML string and loads it into the XMLDocument2 object","!type":"fn(xmlDoc: string) -> bool"},"createElement":{"!doc":"Creates and adds an element node to the current node. The element name is the string passed in as a parameter. The new element node has no text child nodes","!type":"fn(name: string) -> +XMLNode"},"toString":{"!doc":"Returns a string containing the XML","!type":"fn() -> string"},"getNode":{"!doc":"Gets the node specified in the xpath","!type":"fn(xpath: string) -> +XMLNode"},"getNodeText":{"!doc":"Gets all the text child nodes from the node referenced in the xpath","!type":"fn(xpath: string) -> string"}}},"event":{"instance":{"!doc":"","!type":"+GlideElement"},"process_on":{"!doc":"","!type":"+GlideElement"},"user_name":{"!doc":"","!type":"+GlideElement"},"!doc":"Scoped GlideRecord is used for database operations instead of writing SQL queries. Provides data access APIs to retrieve, update, and delete records from a table","!proto":"+GlideRecord","sys_mod_count":{"!doc":"","!type":"+GlideElement"},"sys_updated_on":{"!doc":"","!type":"+GlideElement"},"uri":{"!doc":"","!type":"+GlideElement"},"processed":{"!doc":"","!type":"+GlideElement"},"sys_id":{"!doc":"","!type":"+GlideElement"},"sys_updated_by":{"!doc":"","!type":"+GlideElement"},"user_id":{"!doc":"","!type":"+GlideElement"},"sys_created_on":{"!doc":"","!type":"+GlideElement"},"processing_duration":{"!doc":"Time it took to process the event (milliseconds)","!type":"+GlideElement"},"name":{"!doc":"","!type":"+GlideElement"},"descriptive_name":{"!doc":"","!type":"+GlideElement"},"state":{"!doc":"","!type":"+GlideElement"},"parm1":{"!doc":"","!type":"+GlideElement"},"parm2":{"!doc":"","!type":"+GlideElement"},"queue":{"!doc":"Queue name for processor","!type":"+GlideElement"},"sys_created_by":{"!doc":"","!type":"+GlideElement"},"table":{"!doc":"","!type":"+GlideElement"},"claimed_by":{"!doc":"Cluster node that claimed this event","!type":"+GlideElement"}},"GlideDuration":{"!doc":"The scoped GlideDuration class provides methods for working with spans of time or durations. GlideDuration objects store the duration as a date and time from January 1, 1970, 00:00:00. As a result, setValue() and getValue() use the GlideDateTime object for parameters and return values","!type":"fn()","prototype":{"add":{"!doc":"Adds a given duration to the current duration","!type":"fn(value: +GlideDuration) -> +GlideDuration"},"getByFormat":{"!doc":"Gets the current duration in the given format","!type":"fn(format: string) -> string"},"getValue":{"!doc":"Gets internal value of the this duration object. GlidDuration is stored as DateTime","!type":"fn() -> string"},"subtract":{"!doc":"","!type":"fn(value: +GlideDuration) -> +GlideDuration"},"getDisplayValue":{"!doc":"Gets the display value of the duration in number of days, hours, and minutes","!type":"fn() -> string"},"setValue":{"!doc":"Sets the internal value of the GlideDuration object. Internally, GlidDuration is stored as DateTime","!type":"fn(o: ?)"},"getDayPart":{"!doc":"Gets the number of days","!type":"fn() -> number"},"setDisplayValue":{"!doc":"Sets the display value","!type":"fn(asDisplayed: string)"},"getRoundedDayPart":{"!doc":"Gets the rounded number of days. If the time part is more than 12 hours, the return value is rounded up. Otherwise, it is rounded down","!type":"fn() -> number"},"getDurationValue":{"!doc":"Gets the duration value in d HH:mm:ss format","!type":"fn() -> string"}}},"email":{"setSubject":{"!doc":"Override the subject of the message","!type":"fn(subject: string)"},"setFrom":{"!doc":"Override the sender address","!type":"fn(address: string)"},"!doc":"EmailOutbound object ","addAddress":{"!doc":"Type can be cc or bcc","!type":"fn(type: string, address: string, displayName: string)"},"setReplyTo":{"!doc":"Override the reply to address","!type":"fn(address: string)"},"setBody":{"!doc":"Override the body of the message","!type":"fn(message: string)"}},"GlideAggregate":{"!doc":"The scoped GlideAggregate class is an extension of GlideRecord and allows database aggregation (COUNT, SUM, MIN, MAX, AVG) queries to be done. This can be helpful in creating customized reports or in calculations for calculated fields. The GlideAggregate class works only on number fields. Since currency fields are strings, you can't use the GlideAggregate class on currency fields","!type":"fn(tableName: string)","prototype":{"next":{"!doc":"Moves to the next record in the GlideAggregate","!type":"fn() -> bool"},"getRowCount":{"!doc":"Retrieves the number of rows in the GlideRecord","!type":"fn() -> number"},"getAggregateEncodedQuery":{"!doc":"Gets the query necessary to return the current aggregate","!type":"fn() -> string"},"addAggregate":{"!doc":"Adds an aggregate","!type":"fn(aggregate: string, field: string)"},"query":{"!doc":"Issues the query and gets the results","!type":"fn()"},"getTableName":{"!doc":"Retrieves the table name associated with this GlideRecord","!type":"fn() -> string"},"orderBy":{"!doc":"Orders the aggregates using the value of the specified field. The field will also be added to the group-by list","!type":"fn(field: string)"},"orderByDesc":{"!doc":"Sorts the aggregates into descending order based on the specified field","!type":"fn(field: string)"},"hasNext":{"!doc":"Determines if there are any more results in the GlideAggregate","!type":"fn() -> bool"},"groupBy":{"!doc":"Provides the name of a field to use in grouping the aggregates. May be called numerous times to set multiple group fields","!type":"fn(field: string)"},"getEncodedQuery":{"!doc":"Retrieves the encoded query","!type":"fn() -> string"},"addNotNullQuery":{"!doc":"Adds a NOT NULL query to the aggregate","!type":"fn(field: string) -> +GlideQueryCondition"},"orderByAggregate":{"!doc":"Sorts the aggregates based on the specified aggregate and field","!type":"fn(aggregate: string, field: string)"},"addNullQuery":{"!doc":"Adds a NULL query to the aggregate","!type":"fn(field: string) -> +GlideQueryCondition"},"getValue":{"!doc":"Gets the value of a field","!type":"fn(field: string) -> string"},"setGroup":{"!doc":"Sets whether the results are to be grouped","!type":"fn(value: bool)"},"addEncodedQuery":{"!doc":"Adds a query to the aggregate. Adds an encoded query to the other queries that may have been set for this aggregate","!type":"fn(query: string)"},"addQuery":{"!doc":"Adds a query to the aggregate","!type":"fn(field: string, operator: string, value: string) -> +GlideQueryCondition"},"getAggregate":{"!doc":"Gets the value of the specified aggregate","!type":"fn(aggregate: string, field: string) -> string"}}},"sn_ws_err":{"":{"prototype":{}},"NotAcceptableError":{"!doc":"Sets status code 406 and includes the specified message in the response","!type":"fn(message: string)"},"ServiceError":{"!doc":"A generic error message wrapper to set status code and detailed error message in the response","!type":"fn()","prototype":{"setDetail":{"!doc":"The detailed error message","!type":"fn(detail: string)"},"setMessage":{"!doc":"The error message","!type":"fn(message: string)"},"setStatus":{"!doc":"The response status code -- defaults to 500","!type":"fn(code: number)"}}},"UnsupportedMediaTypeError":{"!doc":"Sets status code 415 and includes the specified message in the response","!type":"fn(message: string)"},"ConflictError":{"!doc":"Sets status code 409 and includes the specified message in the response","!type":"fn(message: string)"},"!doc":"Error types which can be set as the response body of a Scripted REST API","NotFoundError":{"!doc":"Sets status code 404 and includes the specified message in the response","!type":"fn(message: string)"},"BadRequestError":{"!doc":"Sets status code 400 and includes the specified message in the response","!type":"fn(message: string)"}},"GlideSession":{"!doc":"GlideSession manages all of the information for a user session. You can retrieve this from gs.getSession()","!type":"fn()","prototype":{"getTimeZoneName":{"!doc":"Get the Time Zone name associated with the user","!type":"fn() -> string"},"putClientData":{"!doc":"Store a value in an active session","!type":"fn(name: string, value: string)"},"getLanguage":{"!doc":"Language used by the user","!type":"fn() -> string"},"getUrlOnStack":{"!doc":"Gets the current URI for the session","!type":"fn() -> string"},"getClientData":{"!doc":"Fetch the value in active session based on the name","!type":"fn(name: string) -> string"},"isInteractive":{"!doc":"Checks if the current session is interactive","!type":"fn() -> bool"},"getClientIP":{"!doc":"Gets the client IP address","!type":"fn() -> string"},"isLoggedIn":{"!doc":"Determines if the current user is currently logged in","!type":"fn() -> bool"},"getCurrentApplicationId":{"!doc":"Gets the ID of current application, defined as a user preference and set by the application picker","!type":"fn() -> string"}}},"gs":{"monthsAgo":{"!doc":"Returns the (UTC) start of the quarter that was the specified number of months ago adjusted for the timezone of the server","!type":"fn(month: number) -> string"},"hoursAgoEnd":{"!doc":"Returns the (UTC) end of the hour that was the specified number of hours ago adjusted for the timezone of the server","!type":"fn(hours: number) -> string"},"endOfThisMonth":{"!doc":"Gets the date and time for the end of this month in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"isInteractive":{"!doc":"Checks if the current session is interactive","!type":"fn() -> bool"},"daysAgoEnd":{"!doc":"Returns the (UTC) end of the day that was the specified number of days ago adjusted for the timezone of the server","!type":"fn(daysAgo: number) -> string"},"beginningOfNextMonth":{"!doc":"Gets the date and time for the beginning of next month in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"hoursAgo":{"!doc":"number of hours ago","!type":"fn(hours: number) -> string"},"quartersAgoEnd":{"!doc":"Returns the (UTC) end of the quarter that was the specified number of quarters ago adjusted for the timezone of the server","!type":"fn(quarters: number) -> string"},"beginningOfThisYear":{"!doc":"Gets the date and time for the beginning of this year in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"getCurrentApplicationId":{"!doc":"Gets the ID of current application, defined as a user preference and set by the application picker","!type":"fn() -> string"},"endOfLastYear":{"!doc":"Gets the date and time for the end of last year in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"endOfNextYear":{"!doc":"Gets the date and time for the end of next year in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"nil":{"!doc":"Queries an object and returns true if the object is null, undefined, or contains an empty string","!type":"fn(o: Object) -> bool"},"beginningOfThisQuarter":{"!doc":"Gets the date and time for the beginning of this quarter in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"isDebugging":{"!doc":"Determines if debugging is active for a specific scope","!type":"fn() -> bool"},"setRedirect":{"!doc":"Set the redirect URI for this transaction. This determines the next page the user will see","!type":"fn(url: string)"},"datePart":{"!doc":"Returns a String of the form :interval,value,operator","!type":"fn(interval: string, value: string, operator: string) -> string"},"generateGUID":{"!doc":"Generates a GUID that can be used when a unique identifier is required","!type":"fn(obj: Object) -> string"},"getNewAppScopeCompanyPrefix":{"!doc":"","!type":"fn() -> string"},"getUserName":{"!doc":"Gets the username, or User ID, of the current user (e.g., abel.tuter)","!type":"fn() -> string"},"info":{"!doc":"Uses the info level to log a message to the system log","!type":"fn(message: string, parm1: Object, parm2: Object, parm3: Object, parm4: Object, parm5: Object)"},"base64Encode":{"!doc":"","!type":"fn(s: string) -> string"},"getUrlOnStack":{"!doc":"Gets the current URI for the session","!type":"fn() -> string"},"monthsAgoStart":{"!doc":"Returns the (UTC) start of the quarter that was the specified number of months ago adjusted for the timezone of the server","!type":"fn(month: number) -> string"},"getCssCacheVersionString":{"!doc":"Gets a string representing the cache version for a CSS file","!type":"fn() -> string"},"getCallerScopeName":{"!doc":"Gets the caller scope name, or returns null if there is no caller","!type":"fn() -> string"},"base64Decode":{"!doc":"","!type":"fn(s: string) -> string"},"minutesAgo":{"!doc":"number of minutes ago","!type":"fn(minutes: number) -> string"},"hoursAgoStart":{"!doc":"Returns the (UTC) start of the hour that was the specified number of hours ago adjusted for the timezone of the server","!type":"fn(hours: number) -> string"},"warn":{"!doc":"Uses the warn level to log a message to the system log","!type":"fn(message: string, parm1: Object, parm2: Object, parm3: Object, parm4: Object, parm5: Object)"},"endOfNextWeek":{"!doc":"Returns the (UTC) end of next week adjusted for the timezone of the server","!type":"fn() -> string"},"beginningOfLastWeek":{"!doc":"Gets the date and time for the beginning of last week in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"hasRole":{"!doc":"Determines if the current user has the specified role","!type":"fn(role: string) -> bool"},"isLoggedIn":{"!doc":"Determines if the current user is currently logged in","!type":"fn() -> bool"},"endOfThisWeek":{"!doc":"Gets the date and time for the end of this week in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"getUserDisplayName":{"!doc":"Gets the display name of the current user (e.g., Abel Tuter, as opposed to abel.tuter)","!type":"fn() -> string"},"beginningOfThisWeek":{"!doc":"Gets the date and time for the beginning of this week in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"getUser":{"!doc":"Returns a reference to the GlideUser object for the current user","!type":"fn() -> +GlideUser"},"urlDecode":{"!doc":"","!type":"fn(url: string) -> string"},"beginningOfLastYear":{"!doc":"Gets the date and time for the beginning of last year in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"tableExists":{"!doc":"Determines if a database table exists","!type":"fn(name: string) -> bool"},"error":{"!doc":"Uses the error level to log a message to the system log","!type":"fn(message: string, parm1: Object, parm2: Object, parm3: Object, parm4: Object, parm5: Object)"},"urlEncode":{"!doc":"","!type":"fn(url: string) -> string"},"endOfThisYear":{"!doc":"Gets the date and time for the end of this year in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"getCurrentScopeName":{"!doc":"Gets the name of the current scope","!type":"fn() -> string"},"yesterday":{"!doc":"Returns (UTC) 24 hours ago adjusted for the timezone of the current session","!type":"fn() -> string"},"daysAgoStart":{"!doc":"Returns the (UTC) start of the day that was the specified number of days ago adjusted for the timezone of the server","!type":"fn(daysAgo: number) -> string"},"beginningOfLastMonth":{"!doc":"Gets the date and time for the beginning of last month in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"beginningOfThisMonth":{"!doc":"Gets the date and time for the beginning of this month in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"beginningOfNextYear":{"!doc":"Gets the date and time for the beginning of next year in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"getDurationDate":{"!doc":"Returns the date of the duration time after January 1","!type":"fn(duration: string) -> string"},"addErrorMessage":{"!doc":"Adds an error message for the current session","!type":"fn(message: string)"},"beginningOfWeek":{"!doc":"Returns the (UTC) beginning of the specified week adjusted for the timezone of the current session","!type":"fn(o: Object) -> string"},"minutesAgoEnd":{"!doc":"Returns the (UTC) end of the minute that was the specified number of minutes ago adjusted for the timezone of the serve","!type":"fn(minutes: number) -> string"},"getSessionID":{"!doc":"Gets the GlideSession Session ID","!type":"fn() -> string"},"endOfNextMonth":{"!doc":"Gets the date and time for the end of next month in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"getUserID":{"!doc":"Gets the sys_id of the current user","!type":"fn() -> string"},"include":{"!doc":"Provides a safe way to call from the sandbox, allowing only trusted scripts to be included","!type":"fn(name: string) -> bool"},"daysAgo":{"!doc":"Returns the (UTC) start of the day that was the specified number of days ago adjusted for the timezone of the server","!type":"fn(days: number) -> string"},"minutesAgoStart":{"!doc":"Returns the (UTC) start of the minute that was the specified number of minutes ago adjusted for the timezone of the serve","!type":"fn(minutes: number) -> string"},"getProperty":{"!doc":"Retrieves a message from UI messages","!type":"fn(key: string, alt: Object) -> string"},"endOfWeek":{"!doc":"Returns the (UTC) end of the specified week adjusted for the timezone of the current session","!type":"fn(o: Object) -> string"},"endOfLastMonth":{"!doc":"Gets the date and time for the end of last month in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"debug":{"!doc":"Uses the debug level to log a message to the system log","!type":"fn(message: string, parm1: Object, parm2: Object, parm3: Object, parm4: Object, parm5: Object)"},"!doc":"The scoped GlideSystem (referred to by the variable name 'gs' in any server-side JavaScript) API provides a number of convenient methods to get information about the system, the current logged in user, etc.","getMessage":{"!doc":"Retrieves a message from UI messages. args is an optional paramter","!type":"fn(id: string, args: ?) -> string"},"endOfThisQuarter":{"!doc":"Gets the date and time for the end of this quarter in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"eventQueue":{"!doc":"Queues an event for the event manager","!type":"fn(name: string, record: +GlideRecord, parm1: string, parm2: string, queue: string)"},"xmlToJSON":{"!doc":"","!type":"fn(xmlString: string) -> +Object"},"addInfoMessage":{"!doc":"Adds an info message for the current session","!type":"fn(message: string)"},"beginningOfNextWeek":{"!doc":"Gets the date and time for the beginning of next week in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"getMaxSchemaNameLength":{"!doc":"","!type":"fn() -> number"},"endOfLastWeek":{"!doc":"Returns the (UTC) end of last week adjusted for the timezone of the server","!type":"fn() -> string"},"quartersAgoStart":{"!doc":"Returns the (UTC) start of the quarter that was the specified number of quarters ago adjusted for the timezone of the server","!type":"fn(quarters: number) -> string"},"getSession":{"!doc":"Gets a reference to the current Glide session","!type":"fn() -> +GlideSession"}},"GlideFilter":{"!doc":"The scoped GlideFilter class allows you to determine if a record meets a specified set of requirements. There is no constructor for scoped GlideFilter, it is accessed by using the global object 'GlideFilter'","checkRecord":{"!doc":"Returns true when the record meets the filter condition","!type":"fn(gr: +GlideRecord, filter: string, value: bool) -> bool"},"!type":"fn()"},"GlideDate":{"!doc":"The scoped GlideDate class provides methods for performing operations on GlideDate objects, such as instantiating GlideDate objects or working with GlideDate fields","!type":"fn()","prototype":{"getByFormat":{"!doc":"Gets the date in the given date format","!type":"fn(format: string) -> string"},"getMonthNoTZ":{"!doc":"Returns the month part of a date with no timezone conversion","!type":"fn() -> number"},"getValue":{"!doc":"Gets the date value stored in the database by the GlideDate object in the internal format, yyyy-MM-dd, and the system time zone, UTC by default","!type":"fn() -> string"},"getYearNoTZ":{"!doc":"Returns the year part of a date with no timezone conversion","!type":"fn() -> number"},"subtract":{"!doc":"Gets the duration difference between two GlideDate values","!type":"fn(start: +GlideDate, end: +GlideDate) -> +GlideDuration"},"getDisplayValue":{"!doc":"Gets the date in the current user's display format and time zone","!type":"fn() -> string"},"setValue":{"!doc":"Sets the date of the GlideDate object","!type":"fn(o: ?)"},"getDisplayValueInternal":{"!doc":"Gets the display value in the internal format (yyyy-MM-dd). Note: This method is useful for date or time fields, but not date fields","!type":"fn() -> string"},"getDayOfMonthNoTZ":{"!doc":"Returns the day part of a date with no timezone conversion","!type":"fn() -> number"},"setDisplayValue":{"!doc":"Sets a date value using the current user's display format and time zone","!type":"fn(asDisplayed: string)"}}},"GlideScriptedProcessor":{"!doc":"ServiceNow processors are equivalent to Java servlets. Processors provide a customizable URL endpoint that can execute arbitrary server-side Javascript code and produce output such as TEXT, JSON, or HTML. The GlideScriptedProcessor APIs are used in processor scripts to access the the processor (servlet) capabilities. There are no constructors for the GlideScriptedProcessor APIs. The methods are called using the global variable g_processor. A useful global variable, g_target, is available in processor scripts. It contains the table name extracted from the URL. The URL to a processor has the format: https://<instance name.servicenow.com>/<path endpoint>.do?<parameter endpoint>=<value> where the path endpoint and parameter endpoint are defined on the processor form","!type":"fn()","prototype":{"redirect":{"!doc":"Redirects to the specified URL","!type":"fn(url: string)"},"writeOutput":{"!doc":"Writes the contents of the given string to the response","!type":"fn(contentType: string, value: string)"},"writeJSON":{"!doc":"Writes a JSON object to the current URL. Note: Works only in scoped apps","!type":"fn(jsonObject: ?)"}}},"sn_ws_int":{"":{"prototype":{}},"WSSoapRequestDocument":{"!doc":"SOAP request object as a DOM Document or XMLDocument2 (for new application scope)","!type":"Object"},"!doc":"These objects are relevant to Scripted REST APIs and are accessed via the request or response input parameters to Scripted APIs","RESTAPIResponseStream":{"!doc":"Allows you to write streams or strings directly to the response stream in a Scripted REST API","!type":"fn()","prototype":{"writeStream":{"!doc":"Write an InputStream directly to the response stream. Can be called multiple times. Caller responsible for response format and setting proper Content-Type and status code prior to calling","!type":"fn(inputStream: Object)"},"writeString":{"!doc":"Write a string directly to the response stream. Can be called multiple times. Caller responsible for response format and setting proper Content-Type and status code prior to calling","!type":"fn(stringToWrite: string)"}}},"RESTAPIResponse":{"!doc":"Allows you to configure the HTTP response in Scripted REST APIs","!type":"fn()","prototype":{"setHeaders":{"!doc":"Set response headers from the specified object","!type":"fn(headers: ?)"},"getStreamWriter":{"!doc":"Return stream writer. Caller responsible to set proper content type and status using setStatus and setHeader methods. Caller responsible to populate all headers on response before actually writing to stream","!type":"fn() -> +sn_ws_int.RESTAPIResponseStream"},"setLocation":{"!doc":"Set the Location header","!type":"fn(locationValue: string)"},"setError":{"!doc":"Set Response Error","!type":"fn(error: ?)"},"setContentType":{"!doc":"Set the Content-Type header","!type":"fn(contentType: string)"},"setBody":{"!doc":"Use the specified object as the response body","!type":"fn(body: ?)"},"setStatus":{"!doc":"Set response HTTP status code","!type":"fn(code: number)"},"setHeader":{"!doc":"Set a response header","!type":"fn(name: string, value: string)"}}},"WSRequest":{"!doc":"Provides access to request input parameters","!type":"fn()","prototype":{"<input parameter name>":{"!doc":"Use request.<parameter name> to get the value of an input parameter"}}},"WSResponse":{"!doc":"Allows setting response output parameters","!type":"fn()","prototype":{"<output parameter name>":{"!doc":"Use response.<parameter name> to assign a value to an output parameter"},"soapResponseElement":{"!doc":"Use this variable to assign a response value as a DOM Element"}}},"WSSoapRequestXML":{"!doc":"SOAP request object as a String","!type":"string"},"RESTAPIRequest":{"!doc":"Allows you to access request details in Scripted REST APIs","!type":"fn()","prototype":{"headers":{"!doc":"All headers from the request"},"pathParams":{"!doc":"The variable path parameters passed in the request URI as an object"},"queryParams":{"!doc":"The query parameters from the request as an object"},"getRequestedQueryCategory":{"!doc":"Get the query category (i.e. read replica category) from query parameter 'sysparm_query_category'","!type":"fn() -> string"},"getSupportedResponseContentTypes":{"!doc":"Obtain a set of media types that are common between what the client request accepts and what this service is able to produce","!type":"fn() -> Object"},"body":{"!doc":"The body of the request","!type":"+sn_ws_int.RESTAPIRequestBody"},"queryString":{"!doc":"The entire query string from the request URI","!type":"string"},"uri":{"!doc":"The request URI, excluding domain information","!type":"string"},"url":{"!doc":"The entire request URL, including domain","!type":"string"},"getHeader":{"!doc":"Get the value of a specific header from the request","!type":"fn(headerName: string) -> string"}}},"RESTAPIRequestBody":{"!doc":"Allows you to access the request body as a stream, as a string, de-serialized into an object, or as an array of obects","!type":"fn()","prototype":{"nextEntry":{"!doc":"Returns the next entry from the request body as an object if request is array. If not an array then returns entire request body as an object","!type":"fn() -> Object"},"data":{"!doc":"The request body de-serialized as an object"},"dataString":{"!doc":"The request body as a string -- be careful to consider impact to memory","!type":"string"},"dataStream":{"!doc":"The body of the request as a stream. Note, this object provides no functions to manipulate the stream from script. Rather this object can be passed to another API which takes an InputStream as an input parameter","!type":"+GlideScriptableInputStream"},"hasNext":{"!doc":"Return true if request has more entries. Use this in conjunction with nextEntry","!type":"fn() -> bool"}}}},"GlideTime":{"!doc":"The scoped GlideTime class provides methods for performing operations on GlideTime objects, such as instantiating GlideTime objects or working with GlideTime fields","!type":"fn()","prototype":{"getByFormat":{"!doc":"Gets the time in the given time format","!type":"fn(format: string) -> string"},"subtract":{"!doc":"Gets the duration difference between two GlideTime values","!type":"fn(start: +GlideTime, end: +GlideTime) -> +GlideDuration"},"getHourLocalTime":{"!doc":"Returns hour part of local time 0-11","!type":"fn() -> number"},"setDisplayValue":{"!doc":"Sets a time value using the current user's display format and time zone","!type":"fn(asDisplayed: string)"},"getHourUTC":{"!doc":"Returns hour part of UTC time 0-11","!type":"fn() -> number"},"getValue":{"!doc":"Gets the time value stored in the database by the GlideTime object in the internal format, HH:mm:ss, and the system time zone, UTC by default","!type":"fn() -> string"},"getMinutesUTC":{"!doc":"Returns minutes part of UTC time","!type":"fn() -> number"},"getSeconds":{"!doc":"Returns seconds part of time","!type":"fn() -> number"},"getDisplayValue":{"!doc":"Gets the time in the current user's display format and time zone","!type":"fn() -> string"},"setValue":{"!doc":"Sets the time of the GlideTime object in the internal time zone, which is UTC by default or the value of the glide.sys.internal.tz property, if set","!type":"fn(value: ?)"},"getDisplayValueInternal":{"!doc":"Gets the display value in the current user's time zone and the internal format (HH:mm:ss). Useful for date/time fields, but not for date fields","!type":"fn() -> string"},"getHourOfDayLocalTime":{"!doc":"Returns hour-of-the-day part of local time 0-23","!type":"fn() -> number"},"getHourOfDayUTC":{"!doc":"Returns the hour-of-the-day part of UTC time 0-23","!type":"fn() -> number"},"getMinutesLocalTime":{"!doc":"Returns minutes part of local time","!type":"fn() -> number"}}},"GlideUser":{"!doc":"The Scoped GlideUser API provides access to information about the current user and current user roles. Using the Scoped GlideUser API avoids the need to use the slower GlideRecord queries to get user information","!type":"fn()","prototype":{"getName":{"!doc":"Gets the user id, or login name, of the current user","!type":"fn() -> string"},"getDisplayName":{"!doc":"Gets the display name of the current user","!type":"fn() -> string"},"getCompanyID":{"!doc":"Gets the Company ID of the current user","!type":"fn() -> string"},"hasRole":{"!doc":"Determines if the current user has the specified role","!type":"fn(role: string) -> bool"},"getID":{"!doc":"Gets the sys_id of current user","!type":"fn() -> string"},"isMemberOf":{"!doc":"Determines if the current user is a member of the specified group","!type":"fn(group: string) -> bool"},"savePreference":{"!doc":"Saves a user preference value to the database","!type":"fn(name: string, value: string)"},"getPreference":{"!doc":"Gets the specified user preference value for the current user","!type":"fn(name: string) -> string"}}},"GlideSchedule":{"!doc":"The scoped GlideSchedule API provides methods for performing operations on GlideSchedule objects, such as adding new schedule segments to a schedule, determining if a datetime is within the schedule, or setting the schedule timezone","!type":"fn()","prototype":{"add":{"!doc":"Adds a new schedule segment to the current schedule","!type":"fn(startDate: +GlideDateTime, offset: +GlideDuration) -> GlideDateTime"},"duration":{"!doc":"Determines the elapsed time in the schedule between two date time values using the timezone of the schedule or, if that is not specified, the timezone of the session","!type":"fn(startDate: +GlideDateTime, endDate: +GlideDateTime) -> +GlideDuration"},"getName":{"!doc":"Gets the current schedule name","!type":"fn() -> string"},"load":{"!doc":"Loads a schedule with the schedule information. If a timezone is not specified or is nil, the current session timezone is used for the schedule","!type":"fn(sysID: string, timeZone: string, excludeSpanID: string)"},"isValid":{"!doc":"Determines if the current schedule is valid. A schedule is valid if it has at least one schedule span","!type":"fn() -> bool"},"setTimeZone":{"!doc":"Sets the timezone for the current schedule","!type":"fn(tz: string)"}}},"GlideElement":{"!doc":"The Scoped GlideElement API provides methods for dealing with fields and their values. Scoped GlideElement methods are available for the fields of the current GlideRecord","!type":"fn()","prototype":{"getCurrencyCode":{"!doc":"Gets the currency ISO code for a record","!type":"fn() -> string"},"getLabel":{"!doc":"Gets the object's label","!type":"fn() -> string"},"getName":{"!doc":"Gets the name of the field","!type":"fn() -> string"},"getBooleanAttribute":{"!doc":"Gets the value of the attribute on the field in question from the dictionary as a string. To get the value as a string, use getAttribute(string)","!type":"fn(attribute: string) -> bool"},"canRead":{"!doc":"Determines if the GlideRecord table can be read from","!type":"fn() -> bool"},"changes":{"!doc":"Determines if the current field has been modified","!type":"fn() -> bool"},"getReferenceDisplayValue":{"!doc":"Gets the display value","!type":"fn() -> string"},"getCurrencyString":{"!doc":"Gets currency in a string","!type":"fn() -> string"},"getReferenceTable":{"!doc":"Gets table name for a reference field","!type":"fn() -> string"},"getReferenceValue":{"!doc":"Gets the reference value","!type":"fn() -> string"},"nil":{"!doc":"Determines whether the field is null","!type":"fn() -> bool"},"getSessionDisplayValue":{"!doc":"Gets the currency value in the sessions currency format","!type":"fn() -> string"},"getDecryptedValue":{"!doc":"Gets the decrypted value","!type":"fn() -> string"},"getAttribute":{"!doc":"Gets the value of the attribute on the field in question from the dictionary as a string. If the attribute is a boolean attribute, use getBooleanAttribute(String) to get the value as a boolean rather than as a string","!type":"fn(attribute: string) -> string"},"getCurrencyDisplayValue":{"!doc":"Gets the currency display value","!type":"fn() -> string"},"getSessionCurrencyCode":{"!doc":"Gets the sessions currency ISO code","!type":"fn() -> string"},"getCurrencyValue":{"!doc":"Gets a currency value","!type":"fn() -> string"},"getReferenceCurrencyCode":{"!doc":"The currency ISO code, in the base system currency","!type":"fn() -> string"},"changesTo":{"!doc":"Determines if the new value of a field after a change matches a certain object","!type":"fn(value: ?) -> bool"},"getChoices":{"!doc":"Retrieves the choice list for a field","!type":"fn(dependent: string) -> []"},"getTableName":{"!doc":"Gets the table name","!type":"fn() -> string"},"hasAttribute":{"!doc":"Determines whether a field has a particular attribute","!type":"fn(attribute: string) -> bool"},"setDateNumericValue":{"!doc":"Sets a date to a numeric value","!type":"fn(value: ?)"},"setDisplayValue":{"!doc":"Sets the display value of the field","!type":"fn(value: ?)"},"getRefRecord":{"!doc":"Gets a GlideRecord object for a reference element","!type":"fn() -> +GlideRecord"},"canWrite":{"!doc":"Determines if the GlideRecord table can be written to","!type":"fn() -> bool"},"changesFrom":{"!doc":"Determines the previous value of the current field matched a certain object","!type":"fn(value: ?) -> bool"},"canCreate":{"!doc":"Determines if the user's role permits creation of new records in this field","!type":"fn() -> bool"},"getED":{"!doc":"Gets the field's element descriptor","!type":"fn() -> +GlideElementDescriptor"},"getSessionValue":{"!doc":"Gets the ammount in the sessions currency","!type":"fn() -> string"},"dateNumericValue":{"!doc":"Gets date in numberic value","!type":"fn(value: string) -> number"},"setError":{"!doc":"Adds an error message. Can be retrieved using getError()","!type":"fn(message: string)"},"setValue":{"!doc":"Sets the display value of the field","!type":"fn(value: ?)"},"getDisplayValue":{"!doc":"Gets the formatted display value of the field","!type":"fn(maxCharacters: number) -> string"},"toString":{"!doc":"Converts the value to a string","!type":"fn() -> string"}}},"GlideDateTime":{"!doc":"The scoped GlideDateTime default constructor, instantiates a new GlideDateTime object with the current date and time in Greenwich Mean Time (GMT). Optional 'value' parameter with a date and time value in the UTC time zone specified with the format yyyy-MM-dd HH:mm:ss","!type":"fn(value: string)","prototype":{"getDayOfWeekLocalTime":{"!doc":"Gets the day of the week stored by the GlideDateTime object, expressed in the user's time zone","!type":"fn() -> number"},"before":{"!doc":"Returns true if the object's data time is before the input argument","!type":"fn(object: +GlideDateTime) -> bool"},"addWeeksUTC":{"!doc":"Adds a specified number of weeks to the current GlideDateTime object, expressed in the UTC time zone","!type":"fn(amount: number)"},"getDaysInMonthLocalTime":{"!doc":"Sets the day of the month to a specified value in the user's time zone","!type":"fn() -> number"},"setMonthUTC":{"!doc":"Sets the month stored by the GlideDateTime object to a specified value using the UTC time zone","!type":"fn(month: number)"},"compareTo":{"!doc":"Compares two GlideDateTime objects","!type":"fn(object: +GlideDateTime) -> number"},"setGlideDateTime":{"!doc":"Sets the date and time of the current object using an existing GlideDateTime object. This method is equivalent to instantiating a new object with a GlideDateTime parameter","!type":"fn(gdt: +GlideDateTime)"},"setMonthLocalTime":{"!doc":"Sets the month stored by the GlideDateTime object to a specified value using the current user's time zone","!type":"fn(month: number)"},"getMonthLocalTime":{"!doc":"Gets the month stored by the GlideDateTime object, expressed in the current user's time zone","!type":"fn() -> number"},"getLocalDate":{"!doc":"Gets the date for the user's time zone","!type":"fn() -> +GlideDate"},"setYearUTC":{"!doc":"Sets the year stored by the GlideDateTime object to a specified value using the UTC time zone","!type":"fn(year: number)"},"getDayOfWeekUTC":{"!doc":"Gets the day of the week stored by the GlideDateTime object, expressed in the UTC time zone","!type":"fn() -> number"},"getWeekOfYearUTC":{"!doc":"Gets the number of the current week of the current year","!type":"fn() -> number"},"setDayOfMonthLocalTime":{"!doc":"Sets the day of the month to a specified value in the local time zone","!type":"fn(day: number)"},"addYearsUTC":{"!doc":"Adds a specified number of years to the current GlideDateTime object, expressed in the UTC time zone","!type":"fn(amount: number)"},"onOrAfter":{"!doc":"Returns true if the object's data time is on or after the input argument","!type":"fn(object: +GlideDateTime) -> bool"},"add":{"!doc":"Adds a GlideTime object to the current GlideDateTime object","!type":"fn(gt: +GlideTime)"},"getInternalFormattedLocalTime":{"!doc":"Returns local time with internal time format","!type":"fn() -> string"},"subtract":{"!doc":"Gets the duration difference between two GlideDateTime values. Pass a single paramter which specifies milliseconds to subtract from the current GlideDateTime object","!type":"fn(start: +GlideDateTime, end: +GlideDateTime) -> +GlideDuration"},"getWeekOfYearLocalTime":{"!doc":"Gets the number of the week stored by the GlideDateTime object, expressed in the user's time zone","!type":"fn() -> number"},"getDisplayValueWithoutTZ":{"!doc":"","!type":"fn() -> string"},"setDisplayValue":{"!doc":"Sets a date and time value using the current user's display format and time zone. Also set an optional parameter 'format', to set date and time format","!type":"fn(value: string, format: string)"},"getUserFormattedLocalTime":{"!doc":"Returns local time with user time format","!type":"fn() -> string"},"getMonthUTC":{"!doc":"Gets the month stored by the GlideDateTime object, expressed in the UTC time zone","!type":"fn() -> number"},"addSeconds":{"!doc":"Adds a specified number of seconds to the current GlideDateTime object","!type":"fn(value: number)"},"getDaysInMonthUTC":{"!doc":"Gets the number of days in the month stored by the GlideDateTime object, expressed in the UTC time zone","!type":"fn() -> number"},"getLocalTime":{"!doc":"Returns a GlideTime object that represents the time portion of the GlideDateTime object in the user's time zone","!type":"fn() -> +GlideTime"},"addYearsLocalTime":{"!doc":"Adds a specified number of years to the current GlideDateTime object, expressed in the user's time zone","!type":"fn(amount: number)"},"getYearLocalTime":{"!doc":"Gets the year stored by the GlideDateTime object, expressed in the current user's time zone","!type":"fn() -> number"},"getDayOfMonthUTC":{"!doc":"Gets the day of the month stored by the GlideDateTime object, expressed in the UTC time zone","!type":"fn() -> number"},"getNumericValue":{"!doc":"Gets the number of milliseconds since January 1, 1970, 00:00:00 Greenwich Mean Time (GMT)","!type":"fn() -> number"},"getTime":{"!doc":"Returns a GlideTime object that represents the time portion of the GlideDateTime object","!type":"fn() -> +GlideTime"},"isDST":{"!doc":"Determines if an object's time uses a daylight savings offset","!type":"fn() -> bool"},"addMonthsUTC":{"!doc":"Adds a specified number of months to the current GlideDateTime object, expressed in the UTC time zone","!type":"fn(amount: number)"},"addDaysLocalTime":{"!doc":"Adds a specified number of days to the current GlideDateTime object, expressed in the user's timezone","!type":"fn(amount: number)"},"getDSTOffset":{"!doc":"Gets the amount of time that daylight savings time is offset","!type":"fn() -> number"},"hashCode":{"!doc":"","!type":"fn() -> number"},"addMonthsLocalTime":{"!doc":"Adds a specified number of months to the current GlideDateTime object, expressed in the user's time zone","!type":"fn(amount: number)"},"getDisplayValueInternal":{"!doc":"Gets the display value in the internal datetime format","!type":"fn() -> string"},"getDayOfMonthLocalTime":{"!doc":"Gets the day of the month stored by the GlideDateTime object, expressed in the current user's time zone","!type":"fn() -> number"},"getDate":{"!doc":"Gets the date in the system time zone","!type":"fn() -> +GlideDate"},"after":{"!doc":"Returns true if the object's data time is after the input argument","!type":"fn(object: +GlideDateTime) -> bool"},"getErrorMsg":{"!doc":"Gets the current error message","!type":"fn() -> string"},"getTZOffset":{"!doc":"","!type":"fn() -> number"},"setDisplayValueInternal":{"!doc":"Sets a date and time value using the internal format and the current user's time zone","!type":"fn(value: string)"},"onOrBefore":{"!doc":"Returns true if the object's data time is on or before the input argument","!type":"fn(object: +GlideDateTime) -> bool"},"setDayOfMonthUTC":{"!doc":"Sets the day of the month to a specified value in the UTC time zone","!type":"fn(day: number)"},"isValid":{"!doc":"Determines if a value is a valid datetime","!type":"fn() -> bool"},"hasDate":{"!doc":"Determines if an object's date is set","!type":"fn() -> bool"},"setYearLocalTime":{"!doc":"Sets the year stored by the GlideDateTime object to a specified value using the current user's time zone","!type":"fn(year: number)"},"setValueUTC":{"!doc":"Sets a date and time value using the UTC time zone and the specified date and time format","!type":"fn(dt: string, format: string)"},"getValue":{"!doc":"Gets a datetiime value in the same format as it is stored in the database","!type":"fn() -> string"},"getYearUTC":{"!doc":"Gets the year stored by the GlideDateTime object, expressed in the UTC time zone","!type":"fn() -> number"},"equals":{"!doc":"","!type":"fn(object: +GlideDateTime) -> bool"},"getDisplayValue":{"!doc":"Gets the datetime in the current user's display format and time zone","!type":"fn() -> string"},"setValue":{"!doc":"Sets the date and time","!type":"fn(value: number)"},"toString":{"!doc":"Converts a datetime value to a string","!type":"fn() -> string"},"addDaysUTC":{"!doc":"Adds a specified number of days to the current GlideDateTime object, expressed in the UTC time zone","!type":"fn(amount: number)"},"addWeeksLocalTime":{"!doc":"Adds a specified number of weeks to the current GlideDateTime object, expressed in the user's timezone","!type":"fn(amount: number)"}}},"GlideDBFunctionBuilder":{"!doc":"The Scoped GlideDBFunctionBuilder provides a builder API for creating platform function definition","!type":"fn()","prototype":{"add":{"!doc":"Start an addition function","!type":"fn() -> +GlideDBFunctionBuilder"},"constant":{"!doc":"Add a constant parameter to the current function","!type":"fn(constant: string) -> +GlideDBFunctionBuilder"},"endfunc":{"!doc":"End the current function","!type":"fn() -> +GlideDBFunctionBuilder"},"subtract":{"!doc":"Start a subtraction function","!type":"fn() -> +GlideDBFunctionBuilder"},"length":{"!doc":"Start a length function","!type":"fn() -> +GlideDBFunctionBuilder"},"concat":{"!doc":"Start a concatenation function","!type":"fn() -> +GlideDBFunctionBuilder"},"datediff":{"!doc":"Start a function that return the duration between 2 dates","!type":"fn() -> +GlideDBFunctionBuilder"},"field":{"!doc":"Add a field parameter to the current function","!type":"fn(fieldName: string) -> +GlideDBFunctionBuilder"},"build":{"!doc":"Return the completed function definition","!type":"fn() -> string"},"now":{"!doc":"Start a function that returns the current timestamp in the UTC timezone. This function should be used as a parameter to the datediff function to calculate a duration between the current datetime and another datetime field or datetime constant","!type":"fn() -> +GlideDBFunctionBuilder"},"dayofweek":{"!doc":"Start a function that returns the day of the week of a given date","!type":"fn() -> +GlideDBFunctionBuilder"},"divide":{"!doc":"Start a division function","!type":"fn() -> +GlideDBFunctionBuilder"},"multiply":{"!doc":"Start a multiplication function","!type":"fn() -> +GlideDBFunctionBuilder"}}},"sn_clotho":{"":{"prototype":{}},"TransformResult":{"!doc":"An object that contains a transform execution result","!type":"fn()","prototype":{"getByLabel":{"!doc":"Returns a series with the specified label","!type":"fn(label: string) -> +sn_clotho.Data"},"byGroup":{"!doc":"Returns a mapping of group names to their series","!type":"fn() -> +map"},"toArray":{"!doc":"Returns the all series of this TransformResult in the form of an array","!type":"fn() -> [+sn_clotho.Data]"},"getData":{"!doc":"Returns this result's series, assuming that there is a single resultant series","!type":"fn() -> +sn_clotho.Data"}}},"Transformer":{"!doc":"Instantiates a MetricBase transformer for the specified GlideRecord","!type":"fn(gr: +GlideRecord)","prototype":{"metric":{"!doc":"Specifies the metric field that this transformer operates on","!type":"fn(metricName: string) -> +sn_clotho.TransformPart"},"groupBy":{"!doc":"Groups the subject records by the specified field","!type":"fn(field: string) -> +sn_clotho.TransformPart"},"execute":{"!doc":"Executes the transforms defined by this transformer over the specified time range and returns an object containing the results","!type":"fn(rangeStart: +GlideDateTime, rangeEnd: +GlideDateTime) -> +sn_clotho.TransformResult"}}},"DataBuilder":{"!doc":"Builds data to put into MetricBase","!type":"fn(cx: Context, args: [object], ctorObj: Function, inNewExpr: boolean)","prototype":{"add":{"!doc":"Adds the specified value to the data at the specified time","!type":"fn(start: +GlideDateTime, value: number) -> +sn_clotho.DataBuilder"}}},"!doc":"MetricBase JavaScript API","TransformPart":{"!doc":"Defines a transformer's transforms","!type":"fn()","prototype":{"sub":{"!doc":"Subtracts the specified constant quantity from all values","!type":"fn(substrahend: number) -> +sn_clotho.TransformPart"},"mul":{"!doc":"Multiplies all values by the specified constant quantity","!type":"fn(factor: number) -> +sn_clotho.TransformPart"},"log":{"!doc":"Performs a logarithm on all values with the specified constant base","!type":"fn(base: number) -> +sn_clotho.TransformPart"},"sum":{"!doc":"Produces a new series where each value is the sum of all of the values at each timestamp","!type":"fn() -> +sn_clotho.TransformPart"},"groupBy":{"!doc":"Groups the subject records by the specified field","!type":"fn(field: string) -> +sn_clotho.TransformPart"},"div":{"!doc":"Divides all values by the specified constant quantity","!type":"fn(divisor: number) -> +sn_clotho.TransformPart"},"fit":{"!doc":"Fits the series to the specified model using the specified parameters","!type":"fn(_params: object) -> +sn_clotho.TransformPart"},"avg":{"!doc":"Produces a new series where each value is the average of all of the values at each timestamp","!type":"fn() -> +sn_clotho.TransformPart"},"min":{"!doc":"Produces a new series with the smallest values at each timestamp","!type":"fn() -> +sn_clotho.TransformPart"},"partition":{"!doc":"Produces a new series with the values filtered (AVG, MAX, MIN or LAST) by non-overlapping windows","!type":"fn(_aggregator: string, _window: string, _base: string) -> +sn_clotho.TransformPart"},"top":{"!doc":"Produces a set of series with the top 'count' (specified) largest values at each timestamp","!type":"fn(count: number) -> +sn_clotho.TransformPart"},"limit":{"!doc":"Limits the number of data points in each series to the specified count","!type":"fn(count: number) -> +sn_clotho.TransformPart"},"where":{"!doc":"Produces a set of new series by specified condition","!type":"fn(condition: Condition) -> +sn_clotho.TransformPart"},"stddev":{"!doc":"Produces a new series with the standard deviation of the values at each timestamp","!type":"fn() -> +sn_clotho.TransformPart"},"floor":{"!doc":"Floors all values to the specified precision","!type":"fn(precision: number) -> +sn_clotho.TransformPart"},"fractiles":{"!doc":"Produces a set of series where each is one of the specified percentiles of all of the data","!type":"fn(fractions: [number]) -> +sn_clotho.TransformPart"},"add":{"!doc":"Adds the specified constant quantity to all values","!type":"fn(summand: number) -> +sn_clotho.TransformPart"},"max":{"!doc":"Produces a new series with the largest values at each timestamp","!type":"fn() -> +sn_clotho.TransformPart"},"bottom":{"!doc":"Produces a set of series with the bottom 'count' (specified) smallest values at each timestamp","!type":"fn(count: number) -> +sn_clotho.TransformPart"},"count":{"!doc":"Produces a new series that counts the number of series with values in the input","!type":"fn() -> +sn_clotho.TransformPart"},"interpolate":{"!doc":"Populates missing (NaN) values with two-point linear regression using the specified tolerance for maximum range of missing data","!type":"fn(countOrDuration: object) -> +sn_clotho.TransformPart"},"label":{"!doc":"Labels this series","!type":"fn(label: string) -> +sn_clotho.TransformPart"},"ceil":{"!doc":"Ceils all values to the specified precision","!type":"fn(precision: number) -> +sn_clotho.TransformPart"},"filter":{"!doc":"Produces a new series with the values filtered (AVG, MAX, MIN or LAST) by sliding windows","!type":"fn(_aggregator: string, _window: string) -> +sn_clotho.TransformPart"},"median":{"!doc":"Produces a new series with the median of the values at each timestamp","!type":"fn() -> +sn_clotho.TransformPart"},"round":{"!doc":"Rounds all values to the specified precision","!type":"fn(precision: number) -> +sn_clotho.TransformPart"},"metric":{"!doc":"Specifies the metric field that this transformer operates on","!type":"fn(metricName: string) -> +sn_clotho.TransformPart"},"collect":{"!doc":"Includes this intermediate transform as part of the result","!type":"fn() -> +sn_clotho.TransformPart"},"resample":{"!doc":"Aligns all series to have the specified number of data points","!type":"fn(numValues: number) -> +sn_clotho.TransformPart"}}},"Data":{"!doc":"Stores a single series of MetricBase data","!type":"fn()","prototype":{"getSubject":{"!doc":"Returns the value of the subject this series operates on","!type":"fn() -> string"},"fromModelString":{"!doc":"Converts the specified model string into a series","!type":"fn(model: string) -> +sn_clotho.Data"},"getLabel":{"!doc":"Returns the label of this series","!type":"fn() -> string"},"getStart":{"!doc":"Returns the start time of this series","!type":"fn() -> +GlideDateTime"},"size":{"!doc":"Returns the number of values in this series","!type":"fn() -> number"},"getValues":{"!doc":"Returns the values in this series in the form of an array of numbers","!type":"fn() -> [number]"},"getTableName":{"!doc":"Returns the name of the table this series operates on","!type":"fn() -> string"},"getMetricName":{"!doc":"Returns the name of the metric this series operates on","!type":"fn() -> string"},"toModelString":{"!doc":"Converts this series into a model string","!type":"fn() -> string"},"getEnd":{"!doc":"Returns the end time of this series","!type":"fn() -> +GlideDateTime"},"getPeriod":{"!doc":"Returns the period of this series","!type":"fn() -> number"}}},"Client":{"!doc":"Interacts with the MetricBase database","!type":"fn()","prototype":{"transform":{"!doc":"Performs the specified transform(s) over the specified range","!type":"fn(o1: object, o2: +GlideDateTime, o3: +GlideDateTime) -> object"},"put":{"!doc":"Uses the specified DataBuilder to put data into MetricBase","!type":"fn(dataBuilder: +sn_clotho.DataBuilder)"}}}},"GlideLocale":{"!doc":"GlideLocale is a global object that can be called in scripts. Use the get() method to get a GlideLocale object","get":{"!doc":"Returns the GlideLocale object","!type":"fn() -> +GlideLocale"},"!type":"fn()","prototype":{"getGroupingSeparator":{"!doc":"Returns the decimal separator","!type":"fn() -> string"},"getDecimalSeparator":{"!doc":"Returns the grouping separator","!type":"fn() -> string"}}},"XMLNodeIterator":{"!doc":"The scoped XMLNodeIterator class allows you to iterate through a node of a XML document","!type":"fn()","prototype":{"next":{"!doc":"Gets the next element in the iteration","!type":"fn() -> +XMLNode"},"hasNext":{"!doc":"Determines if the iteration has more elements","!type":"fn() -> bool"}}}},"sys_script_include":{"GlideServletRequest":{"!doc":"ServiceNow processors are equivalent to Java servlets. Processors provide a customizable URL endpoint that can execute arbitrary server-side Javascript code and produce output such as TEXT, JSON, or HTML. The GlideServletRequest API is used in processor scripts to access the HttpServletRequest object. The GlideServletRequest object provides a subset of the HttpServletRequest APIs. The methods are called using the global variable g_request. A useful global variable, g_target, is available in processor scripts. It contains the table name extracted from the URL. The URL to a processor has the format: https://<instance name.servicenow.com>/<path endpoint>.do?<parameter endpoint>=<value> where the path endpoint and parameter endpoint are defined on the processor form","!type":"fn()","prototype":{"getHeaders":{"!doc":"Returns an array of headers as a string","!type":"fn(name: string) -> [string]"},"getHeaderNames":{"!doc":"Returns an array of header names as a string","!type":"fn() -> [string]"},"getQueryString":{"!doc":"Returns the query string from the request","!type":"fn() -> string"},"getContentType":{"!doc":"Returns the content type","!type":"fn() -> string"},"getParameterNames":{"!doc":"Returns an array of parameter names as a string","!type":"fn() -> [string]"},"getHeader":{"!doc":"Returns the header","!type":"fn(name: string) -> string"},"getParameter":{"!doc":"Returns an object","!type":"fn(name: string) -> ?"}}},"XMLNode":{"!doc":"The scoped XMLNode API allows you to query values from XML nodes. XMLNodes are extracted from XMLDocument2 objects, which contain XML strings","!type":"fn()","prototype":{"getNodeValue":{"!doc":"Gets the node's value","!type":"fn() -> string"},"appendChild":{"!doc":"","!type":"fn(newChild: +XMLNode)"},"setAttribute":{"!doc":"","!type":"fn(attribute: string, value: string)"},"getChildNodeIterator":{"!doc":"Gets the node's XMLNodeIterator object","!type":"fn() -> +XMLNodeIterator"},"getAttribute":{"!doc":"Gets the value of the specified attribute","!type":"fn(attribute: string) -> string"},"hasAttribute":{"!doc":"Determines if the node has the specified attribute","!type":"fn(attribute: string) -> bool"},"getFirstChild":{"!doc":"Gets the node's first child node","!type":"fn() -> +XMLNode"},"toString":{"!doc":"Gets the node's string value","!type":"fn() -> string"},"getTextContent":{"!doc":"Gets the node's text content","!type":"fn() -> string"},"getNodeName":{"!doc":"Gets the node's name","!type":"fn() -> string"},"getLastChild":{"!doc":"Gets the node's last child node","!type":"fn() -> +XMLNode"}}},"GlideScopedEvaluator":{"!doc":"The API allows you to evaluate scripts from a GlideRecord field","!type":"fn()","prototype":{"evaluateScript":{"!doc":"Evaluates a script from a GlideRecord field. variables parameter is optional","!type":"fn(gr: +GlideRecord, scriptField: string, variables: ?) -> ?"},"putVariable":{"!doc":"Puts a variable into the GlideScopedEvaluator object","!type":"fn(name: string, value: ?)"},"getVariable":{"!doc":"Gets a variable from a GlideScopedEvaluator object","!type":"fn(name: string) -> ?"}}},"GlideTableHierarchy":{"!doc":"The Scoped GlideTableHierarchy API provides methods for handling information about table relationships","!type":"fn()","prototype":{"hasExtensions":{"!doc":"Returns true of this class has been extended","!type":"fn() -> bool"},"getName":{"!doc":"Returns the table's name","!type":"fn() -> string"},"isSoloClass":{"!doc":"Returns true if this table is not in a hierarchy","!type":"fn() -> bool"},"getTables":{"!doc":"Returns a list of the table names in the hierarchy","!type":"fn() -> []"},"getAllExtensions":{"!doc":"Returns a list of all tables that extend the current table and includes the current table","!type":"fn() -> []"},"isBaseClass":{"!doc":"Returns true if this is a base class","!type":"fn() -> bool"},"getTableExtensions":{"!doc":"Returns a list of all tables that extend the current table","!type":"fn() -> []"},"getBase":{"!doc":"Returns the parent class","!type":"fn() -> string"},"getRoot":{"!doc":"Returns the top level class in the hierarchy","!type":"fn() -> string"},"getHierarchy":{"!doc":"Returns a list of all classes in the hierarchy of the given table","!type":"fn() -> []"}}},"GlidePluginManager":{"!doc":"Scoped API for PluginManager","!type":"fn()","prototype":{"isActive":{"!doc":"Determine if a plugin is activated","!type":"fn(pluginID: string) -> bool"}}},"sn_auth":{"":{"prototype":{}},"GlideOAuthClient":{"!doc":"The OAuth client API provides methods to request and revoke OAuth tokens","!type":"fn()","prototype":{"revokeToken":{"!doc":"Revokes the access or refresh token for the client, with the request and optional header parameters set into a GlideOAuthClientRequest object","!type":"fn(clientName: string, accessToken: string, refreshToken: string, request: GlideOAuthClientRequest) -> +sn_auth.GlideOAuthClientResponse"},"requestTokenByRequest":{"!doc":"Retrieves the token for the client, with the request and optional header parameters set into a GlideOAuthClientRequest object","!type":"fn(clientName: string, request: GlideOAuthClientRequest) -> +sn_auth.GlideOAuthClientResponse"},"requestToken":{"!doc":"Retrieves the token for the client, with the request parameters encoded in JSON format","!type":"fn(clientName: string, jsonString: string) -> +sn_auth.GlideOAuthClientResponse"}}},"!doc":"Authentication API","GlideOAuthClientRequest":{"!doc":"Use these methods for handling client requests","!type":"fn()","prototype":{"getRefreshToken":{"!doc":"Retrieves the refresh token","!type":"fn() -> string"},"setPassword":{"!doc":"Sets the password with the string you provide","!type":"fn(password: string)"},"getHeaders":{"!doc":"Retrieves the HTTP headers","!type":"fn() -> ?"},"setHeader":{"!doc":"Sets the HTTP headers for the nave:value pair that you provide","!type":"fn(name: string, value: string)"},"getHeader":{"!doc":"Retrieves the HTTP headers for the string you provide","!type":"fn(name: string)"},"getPassword":{"!doc":"Retrieves the password","!type":"fn() -> string"},"setUserName":{"!doc":"Sets the user name with the string you provide","!type":"fn(userName: string)"},"setParameter":{"!doc":"Sets the parameters for the name:value pair of strings you provide","!type":"fn(name: string, value: string)"},"getGrantType":{"!doc":"Retrieves the grant type","!type":"fn()"},"setGrantType":{"!doc":"Sets the grant type with the string you provide","!type":"fn()"},"getUserName":{"!doc":"Retrieves the user name","!type":"fn() -> string"},"setScope":{"!doc":"Sets the scope with the string you provide","!type":"fn(scope: string)"},"setRefreshToken":{"!doc":"Sets the refresh token with the string you provide","!type":"fn(refreshToken: string)"},"getScope":{"!doc":"Retrieves the scope","!type":"fn() -> string"},"getParameter":{"!doc":"Retrieves the parameter for the parameter name you provide","!type":"fn(name: string)"}}},"GlideOAuthClientResponse":{"!doc":"","!type":"fn()","prototype":{"getResponseParameters":{"!doc":"Retrieves the response content from an external OAuth provider. The response is in a name:value pair","!type":"fn() -> ?"},"getBody":{"!doc":"Retrieves all of the response information, including instance information","!type":"fn() -> string"},"getToken":{"!doc":"Retrieves the refresh token","!type":"fn() -> +sn_auth.GlideOAuthToken"},"getResponseCode":{"!doc":"Retrieves the HTTP response code from the external OAuth provider","!type":"fn() -> string"},"getContentType":{"!doc":"Retrieves the HTTP response content header from an external OAuth provider","!type":"fn() -> string"},"getErrorMessage":{"!doc":"Retrieves the error message if authentication is not successful","!type":"fn() -> string"}}},"GlideOAuthToken":{"!doc":"Use these methods for retrieving the access token and information about the access token","!type":"fn()","prototype":{"getRefreshToken":{"!doc":"Retrieves the refresh token","!type":"fn() -> number"},"getRefreshTokenSysID":{"!doc":"Retrieves the sys_id of the refresh token","!type":"fn() -> string"},"getExpiresIn":{"!doc":"Retrieves the lifespan of the access token in seconds","!type":"fn() -> number"},"getAccessTokenSysID":{"!doc":"Retrieves the sys_id of the token ID","!type":"fn() -> string"},"getScope":{"!doc":"Retrieves the scope, which is the amount of access granted by the access token","!type":"fn() -> string"},"getAccessToken":{"!doc":"Retrieves the access token","!type":"fn() -> string"}}}},"GlideRecord":{"!doc":"Scoped GlideRecord is used for database operations instead of writing SQL queries. Provides data access APIs to retrieve, update, and delete records from a table","!type":"fn(tableName: string)","prototype":{"getLastErrorMessage":{"!doc":"Retrieves the last error message","!type":"fn() -> string"},"getLabel":{"!doc":"The label of the field as a String","!type":"fn() -> string"},"addJoinQuery":{"!doc":"Adds a filter to return records based on a relationship in a related table","!type":"fn(joinTable: string, primaryField: ?, joinTableField: ?) -> +GlideQueryCondition"},"setCategory":{"!doc":"","!type":"fn(category: string)"},"addActiveQuery":{"!doc":"Adds a filter to return active records","!type":"fn() -> +GlideQueryCondition"},"canDelete":{"!doc":"Determines if the Access Control Rules which include the user's roles permit deleting records in this table","!type":"fn() -> bool"},"setAbortAction":{"!doc":"Sets a flag to indicate if the next database action (insert, update, delete) is to be aborted","!type":"fn(b: bool)"},"getRowCount":{"!doc":"Retrieves the number of rows in the GlideRecord","!type":"fn() -> number"},"addFunction":{"!doc":"Retrieve the specified platform function in addition of the field values","!type":"fn(functionDefinition: string)"},"query":{"!doc":"Runs the query against the table based on the specified filters by addQuery and addEncodedQuery","!type":"fn()"},"getTableName":{"!doc":"Retrieves the table name associated with this GlideRecord","!type":"fn() -> string"},"getCategory":{"!doc":"","!type":"fn() -> string"},"orderByDesc":{"!doc":"Specifies a descending orderBy","!type":"fn(fieldName: string)"},"hasNext":{"!doc":"Determines if there are any more records in the GlideRecord","!type":"fn() -> bool"},"getClassDisplayValue":{"!doc":"","!type":"fn() -> string"},"isNewRecord":{"!doc":"Checks if the current record is a new record that has not yet been inserted into the database","!type":"fn() -> bool"},"getEncodedQuery":{"!doc":"Retrieves the query condition of the current result set as an encoded query string","!type":"fn() -> string"},"updateMultiple":{"!doc":"Updates each GlideRecord in the list with any changes that have been made","!type":"fn()"},"getRecordClassName":{"!doc":"Retrieves the class name for the current record","!type":"fn() -> string"},"autoSysFields":{"!doc":"","!type":"fn(b: bool)"},"getDisplayName":{"!doc":"Retrieves the name of the display field","!type":"fn() -> string"},"addQuery":{"!doc":"Adds a filter to return records by specifying a field and value. You can use an optional 'operator' as a second parameter","!type":"fn(name: string, value: string) -> +GlideQueryCondition"},"setLimit":{"!doc":"Sets the maximum number of records in the GlideRecord to be fetched in the next query","!type":"fn(limit: number)"},"getUniqueValue":{"!doc":"Gets the primary key of the record, which is usually the sys_id unless otherwise specified","!type":"fn() -> string"},"next":{"!doc":"Moves to the next record in the GlideRecord","!type":"fn() -> bool"},"deleteMultiple":{"!doc":"Deletes records that satisfy current query condition","!type":"fn()"},"canRead":{"!doc":"Determines if the Access Control Rules which include the user's roles permit reading records in this table","!type":"fn() -> bool"},"insert":{"!doc":"Insert a new record using the field values that have been set for the current record","!type":"fn() -> string"},"update":{"!doc":"Updates the current GlideRecord with any changes that have been made","!type":"fn(reason: ?) -> string"},"orderBy":{"!doc":"Specifies an orderBy column","!type":"fn(fieldName: string)"},"addNotNullQuery":{"!doc":"Adds a filter to return records where the specified field is not null","!type":"fn(fieldName: string) -> +GlideQueryCondition"},"addNullQuery":{"!doc":"Adds a filter to return records where the specified field is null","!type":"fn(fieldName: string) -> +GlideQueryCondition"},"addEncodedQuery":{"!doc":"Adds an encoded query to the other queries that may have been set","!type":"fn(query: string)"},"getAttribute":{"!doc":"Gets the attributes on the field in question from the dictionary","!type":"fn(attribute: string) -> string"},"get":{"!doc":"Defines a GlideRecord based on the specified expression of name = value","!type":"fn(name: ?, value: ?) -> bool"},"isValidRecord":{"!doc":"Determines if current record is a valid record","!type":"fn() -> bool"},"setNewGuidValue":{"!doc":"Sets sys_id value for the current record","!type":"fn(guid: string)"},"isValid":{"!doc":"Determines whether the table exists or not","!type":"fn() -> bool"},"isActionAborted":{"!doc":"Determines whether the current database action is to be aborted. Available in Fuji patch 3","!type":"fn() -> bool"},"chooseWindow":{"!doc":"Sets a range of rows to be returned by subsequent queries. If forceCount is true, getRowCount() method will return all possible records","!type":"fn(firstRow: number, lastRow: number, forceCount: bool)"},"canWrite":{"!doc":"Determines if the Access Control Rules which include the user's roles permit editing records in this table","!type":"fn() -> bool"},"setTextSearchOpts":{"!doc":"Provide additional options for text search query","!type":"fn(textSearchOpts: ?)"},"canCreate":{"!doc":"Determines if the Access Control Rules which include the user's roles permit inserting new records in this table","!type":"fn() -> bool"},"setWorkflow":{"!doc":"Enables and disables the running of business rules and script engines. When disabled, inserts and updates are not audited","!type":"fn(e: bool)"},"getValue":{"!doc":"Retrieves the underlying value of a field","!type":"fn(fieldName: string) -> string"},"getLink":{"!doc":"Retrieves a link to the current record","!type":"fn(nostack: bool) -> string"},"getElement":{"!doc":"Retrieves the GlideElement for a specified field","!type":"fn(fieldName: string) -> +GlideElement"},"setValue":{"!doc":"Sets the value for the specified field.","!type":"fn(fieldName: string, value: ?)"},"getDisplayValue":{"!doc":"Retrieves the display value for the current record","!type":"fn(fieldName: string) -> string"},"isValidField":{"!doc":"Determines if the given field is defined in the current table","!type":"fn(fieldName: string) -> bool"},"initialize":{"!doc":"Creates an empty record suitable for population before an insert","!type":"fn()"},"operation":{"!doc":"Retrieves the current operation being performed, such as insert, update, or delete","!type":"fn() -> string"},"newRecord":{"!doc":"Creates a new GlideRecord, sets the default values for the fields, and assigns a unique ID to the record","!type":"fn()"},"deleteRecord":{"!doc":"Deletes the current record","!type":"fn() -> bool"}}},"sn_ws":{"":{"prototype":{}},"RESTResponseV2":{"!doc":"The RESTResponseV2 API allows you to use the data returned by an outbound REST message in JavaScript code. A RESTResponseV2 object is returned by the RESTMessageV2 functions execute() and executeAsync()","!type":"fn()","prototype":{"getStatusCode":{"!doc":"Get the numeric HTTP status code returned by the REST provider","!type":"fn(name: string) -> number"},"getHeaders":{"!doc":"Deprecated -- use getAllHeaders instead","!type":"fn() -> Object"},"waitForResponse":{"!doc":"Set the amount of time the instance waits for the response","!type":"fn(timeoutSecs: number)"},"getBody":{"!doc":"Get the content of the REST response body","!type":"fn() -> string"},"getErrorCode":{"!doc":"Get the numeric error code, if there was an error during the REST transaction","!type":"fn() -> number"},"getQueryString":{"!doc":"Get the error message if there was an error during the REST transaction","!type":"fn() -> string"},"getAllHeaders":{"!doc":"Get all headers returned in the REST response and the associated values","!type":"fn() -> [+GlideHTTPHeader]"},"haveError":{"!doc":"Indicate if there was an error during the REST transaction","!type":"fn() -> bool"},"getHeader":{"!doc":"Get the value for a specified header","!type":"fn(name: string) -> string"},"getErrorMessage":{"!doc":"Get the query used for this request","!type":"fn() -> string"}}},"!doc":"Web Services API, to send a message to a web service provider","SOAPMessageV2":{"!doc":"Instantiates a SOAPMessageV2 object. Specify optional message and a function if there is a SOAP message record","!type":"fn(soapMessage: string, soapFunction: string)","prototype":{"setMIDServer":{"!doc":"Configure the SOAP message to be sent through a MID Server","!type":"fn(midServerName: string)"},"getRequestBody":{"!doc":"Get the content of the SOAP message body","!type":"fn() -> string"},"getRequestHeader":{"!doc":"Get the value for an HTTP header specified by the SOAP client","!type":"fn(headerName: string) -> string"},"setBasicAuth":{"!doc":"Set basic authentication headers for the SOAP message","!type":"fn(userName: string, userPass: string)"},"setWSSecurityUsernameToken":{"!doc":"Set WS-Security Username token","!type":"fn(username: string, password: string)"},"setRequestHeader":{"!doc":"Set an HTTP header in the SOAP message to the specified value","!type":"fn(headerName: string, headerValue: string)"},"getEndpoint":{"!doc":"Get the URL of the endpoint for the SOAP message","!type":"fn() -> string"},"setWSSecurityX509Token":{"!doc":"Set WS-Security X.509 token","!type":"fn(keystoreId: string, keystoreAlias: string, keystorePassword: string, certificateId: string)"},"setStringParameterNoEscape":{"!doc":"Set a variable from the SOAP message record to the specified value without escaping XML reserved characters","!type":"fn(name: string, value: string)"},"execute":{"!doc":"Send the SOAP Message to the endpoint","!type":"fn() -> +sn_ws.SOAPResponse"},"setHttpTimeout":{"!doc":"Set the amount of time the request waits for a response from the web service provider before the request times out","!type":"fn(timeoutMs: number)"},"setEndpoint":{"!doc":"Set the endpoint for the SOAP message","!type":"fn(endpoint: string)"},"setRequestBody":{"!doc":"Set the body content to send to the web service provider","!type":"fn(requestBody: string)"},"getRequestHeaders":{"!doc":"Get name and value for all HTTP headers specified by the SOAP client","!type":"fn() -> Object"},"setStringParameter":{"!doc":"Set a variable from the SOAP message record to the specified value","!type":"fn(name: string, value: string)"},"setSOAPAction":{"!doc":"Define the SOAP action this SOAP message performs","!type":"fn(soapAction: string)"},"setMutualAuth":{"!doc":"Set the mutual authentication protocol profile for the SOAP message","!type":"fn(profileName: string)"},"setEccCorrelator":{"!doc":"Associate outbound requests and the resulting response record in the ECC queue","!type":"fn(correlator: string)"},"setWSSecurity":{"!doc":"Set web service security values for the SOAP message","!type":"fn(keystoreId: string, keystoreAlias: string, keystorePassword: string, certificateId: string)"},"setEccParameter":{"!doc":"Override a value from the database by writing to the SOAP message payload","!type":"fn(name: string, value: string)"},"executeAsync":{"!doc":"Send the SOAP Message to the endpoint asynchronously","!type":"fn() -> +sn_ws.SOAPResponse"}}},"SOAPResponseV2":{"!doc":"The SOAPResponseV2 API allows you to use the data returned by an outbound SOAP message in JavaScript code. A SOAPResponseV2 object is returned by the SOAPMessageV2 functions execute() and executeAsync()","!type":"fn()","prototype":{"getStatusCode":{"!doc":"Get the numeric HTTP status code returned by the SOAP provider","!type":"fn() -> number"},"getHeaders":{"!doc":"Deprecated -- use getAllHeaders instead","!type":"fn() -> Object"},"waitForResponse":{"!doc":"Set the amount of time the instance waits for a response","!type":"fn(timeoutSecs: number)"},"getBody":{"!doc":"Get the content of the SOAP response body","!type":"fn() -> string"},"getErrorCode":{"!doc":"Get the numeric error code if there was an error during the SOAP transaction","!type":"fn() -> number"},"getAllHeaders":{"!doc":"Get all HTTP headers returned in the SOAP response and the associated values","!type":"fn() -> [+GlideHTTPHeader]"},"haveError":{"!doc":"Indicate if there was an error during the SOAP transaction","!type":"fn() -> bool"},"getHeader":{"!doc":"Get the value for a specified HTTP header","!type":"fn(name: string)-> string"},"getErrorMessage":{"!doc":"Get the error message if there was an error during the SOAP transaction","!type":"fn() -> string"}}},"RESTMessageV2":{"!doc":"Instantiates a RESTMessageV2 object. When you have a REST message record, you can add the optional name and methodName information","!type":"fn(name: string, methodName: string)","prototype":{"setMIDServer":{"!doc":"Configure the REST message to communicate through a MID Server","!type":"fn(midServer: string)"},"getRequestBody":{"!doc":"Get the content of the REST message body","!type":"fn() -> string"},"getRequestHeader":{"!doc":"Get the value for an HTTP header specified by the REST client","!type":"fn(headerName: string) -> string"},"setHttpMethod":{"!doc":"The HTTP method this REST message performs, such as GET or PUT. You must set an HTTP method when using the RESTMessageV2() constructor with no parameters","!type":"fn(method: string)"},"setBasicAuth":{"!doc":"Set basic authentication headers for the REST message","!type":"fn(userName: string, userPass: string)"},"setRequestHeader":{"!doc":"Set an HTTP header to the specified value","!type":"fn(name: string, value: string)"},"setAuthenticationProfile":{"!doc":"Set the credentials for the REST message using an existing basic auth or OAuth 2.0 profile. Valid types are 'basic' and 'oauth2'. Valid profileIds are the sys_id of a Basic Auth Configuration [sys_auth_profile_basic] record or an OAuth Entity Profile [oauth_entity_profile] record","!type":"fn(type: string, profileId: string)"},"setQueryParameter":{"!doc":"Append a name-value parameter to the request URL","!type":"fn(name: string, value: string)"},"setRequestBodyFromAttachment":{"!doc":"Uses the specified attachment as the request body of this REST Message. Mutually exclusive with setRequestBody","!type":"fn(attachmentSysId: string)"},"getEndpoint":{"!doc":"Get the URL of the endpoint for the REST message","!type":"fn() -> string"},"setStringParameterNoEscape":{"!doc":"Set a REST message function variable to the specified value without escaping XML reserved characters","!type":"fn(name: string, value: string)"},"execute":{"!doc":"Send the REST message to the endpoint","!type":"fn() -> +sn_ws.RESTResponseV2"},"setHttpTimeout":{"!doc":"Set the amount of time the REST message waits for a response from the REST provider","!type":"fn(timeoutMs: number)"},"setEndpoint":{"!doc":"Set the endpoint for the REST message","!type":"fn(endpoint: string)"},"setRequestBody":{"!doc":"Set the body content of a PUT or POST request. Mutually exclusive with setRequestBodyFromAttachment","!type":"fn(body: string)"},"getRequestHeaders":{"!doc":"Get name and value for all HTTP headers specified by the REST client","!type":"fn() -> Object"},"saveResponseBodyAsAttachment":{"!doc":"Setup the response body to be saved into the specified attachment when the request is sent. encryptCtxSysId is optional","!type":"fn(tableName: string, recordSysId: string, filename: string, encryptCtxSysId: string)"},"setStringParameter":{"!doc":"Set a REST message function variable to the specified value","!type":"fn(name: string, value: string)"},"setMutualAuth":{"!doc":"Set the mutual authentication protocol profile for the REST message","!type":"fn(profileName: string)"},"setEccTopic":{"!doc":"Set the ECC topic for the REST message. The default ECC topic is RESTProbe if topic is not set. In most cases it is unnecessary to set ECC topic","!type":"fn(topic: string)"},"setEccCorrelator":{"!doc":"Associate outbound requests and the resulting response record in the ECC queue","!type":"fn(correlator: string)"},"setEccParameter":{"!doc":"Override a value from the database by writing to the REST message payload","!type":"fn(name: string, value: string)"},"executeAsync":{"!doc":"Send the REST message to the endpoint asynchronously. The instance does not wait for a response from the web service provider when making asynchronous calls","!type":"fn() -> +sn_ws.RESTResponseV2"},"getEccTopic":{"!doc":"Get the ECC topic for the REST message","!type":"fn() -> string"}}}},"GlideServletResponse":{"!doc":"ServiceNow processors are equivalent to Java servlets. Processors provide a customizable URL endpoint that can execute arbitrary server-side Javascript code and produce output such as TEXT, JSON, or HTML. The GlideServletResponse API is used in processor scripts to access the HttpServletResponse object. The GlideServletResponse object provides a subset of the HttpServletResponse APIs. The methods are called using the global variable g_response. A useful global variable, g_target, is available in processor scripts. It contains the table name extracted from the URL. The URL to a processor has the format: https://<instance name.servicenow.com>/<path endpoint>.do?<parameter endpoint>=<value> where the path endpoint and parameter endpoint are defined on the processor form","!type":"fn()","prototype":{"setContentType":{"!doc":"Sets the MIME type of the response","!type":"fn(type: string)"},"sendRedirect":{"!doc":"Sends a temporary redirect to the client","!type":"fn(location: string)"},"setStatus":{"!doc":"Sets the status code for the response","!type":"fn(status: number)"},"setHeader":{"!doc":"Sets a response header to the specified value","!type":"fn(key: string, value: string)"}}},"GlideElementDescriptor":{"!doc":"The scoped GlideElementDescriptor class provides information about individual fields","!type":"fn()","prototype":{"getName":{"!doc":"Returns the field's name","!type":"fn() -> string"},"getInternalType":{"!doc":"Returns the field's data type","!type":"fn() -> string"},"getLabel":{"!doc":"Returns the field's label","!type":"fn() -> string"},"getLength":{"!doc":"Returns the field's length","!type":"fn() -> number"}}},"GlideQueryCondition":{"!doc":"The scoped QueryCondition API provides additional AND or OR conditions that can be added to the current condition, allowing you to build complex queries such as: category='hardware' OR category='software' AND priority='2' AND priority='1'","!type":"fn()","prototype":{"addOrCondition":{"!doc":"Adds an OR condition to the current condition. oper is an optional parameter","!type":"fn(name: string, oper: string, value: ?) -> +GlideQueryCondition"},"addCondition":{"!doc":"Adds an AND condition to the current condition. oper is an optional parameter","!type":"fn(name: string, oper: string, value: ?) -> +GlideQueryCondition"}}},"GlideScriptableInputStream":{"!doc":"A wrapper around an InputStream. No functions are provided to manipulate the stream from script. Rather this object can be passed to any API which takes an InputStream as an input parameter","!type":"fn()"},"GlideRecordSecure":{"!doc":"GlideRecordSecure is a class inherited from GlideRecord that performs the same functions as GlideRecord, and also enforces ACLs","!type":"GlideRecord"},"XMLDocument2":{"!doc":"XMLDocument2 is a JavaScript Object wrapper for parsing and extracting XML data from an XML string. Use this JavaScript class to instantiate an object from an XML string, usually a return value from a Web Service invocation, or the XML payload of ECC Queue","!type":"fn()","prototype":{"getFirstNode":{"!doc":"Gets the first node in the specified xpath","!type":"fn(xpath: string) -> +XMLNode"},"createElementWithTextValue":{"!doc":"Creates an element node with a text child node and adds it to the current node","!type":"fn(name: string, value: string) -> +XMLNode"},"getNextNode":{"!doc":"Gets the node after the specified node","!type":"fn(prev: +XMLNode) -> +XMLNode"},"isValid":{"!doc":"Checks if the XMLDocument is valid","!type":"fn() -> bool"},"setCurrentElement":{"!doc":"Makes the node passed in as a parameter the current node","!type":"fn(element: +XMLNode)"},"getDocumentElement":{"!doc":"Gets the document element node of the XMLDocument2. The document element node is the root node","!type":"fn() -> +XMLNode"},"parseXML":{"!doc":"Parses the XML string and loads it into the XMLDocument2 object","!type":"fn(xmlDoc: string) -> bool"},"createElement":{"!doc":"Creates and adds an element node to the current node. The element name is the string passed in as a parameter. The new element node has no text child nodes","!type":"fn(name: string) -> +XMLNode"},"toString":{"!doc":"Returns a string containing the XML","!type":"fn() -> string"},"getNode":{"!doc":"Gets the node specified in the xpath","!type":"fn(xpath: string) -> +XMLNode"},"getNodeText":{"!doc":"Gets all the text child nodes from the node referenced in the xpath","!type":"fn(xpath: string) -> string"}}},"GlideDuration":{"!doc":"The scoped GlideDuration class provides methods for working with spans of time or durations. GlideDuration objects store the duration as a date and time from January 1, 1970, 00:00:00. As a result, setValue() and getValue() use the GlideDateTime object for parameters and return values","!type":"fn()","prototype":{"add":{"!doc":"Adds a given duration to the current duration","!type":"fn(value: +GlideDuration) -> +GlideDuration"},"getByFormat":{"!doc":"Gets the current duration in the given format","!type":"fn(format: string) -> string"},"getValue":{"!doc":"Gets internal value of the this duration object. GlidDuration is stored as DateTime","!type":"fn() -> string"},"subtract":{"!doc":"","!type":"fn(value: +GlideDuration) -> +GlideDuration"},"getDisplayValue":{"!doc":"Gets the display value of the duration in number of days, hours, and minutes","!type":"fn() -> string"},"setValue":{"!doc":"Sets the internal value of the GlideDuration object. Internally, GlidDuration is stored as DateTime","!type":"fn(o: ?)"},"getDayPart":{"!doc":"Gets the number of days","!type":"fn() -> number"},"setDisplayValue":{"!doc":"Sets the display value","!type":"fn(asDisplayed: string)"},"getRoundedDayPart":{"!doc":"Gets the rounded number of days. If the time part is more than 12 hours, the return value is rounded up. Otherwise, it is rounded down","!type":"fn() -> number"},"getDurationValue":{"!doc":"Gets the duration value in d HH:mm:ss format","!type":"fn() -> string"}}},"GlideAggregate":{"!doc":"The scoped GlideAggregate class is an extension of GlideRecord and allows database aggregation (COUNT, SUM, MIN, MAX, AVG) queries to be done. This can be helpful in creating customized reports or in calculations for calculated fields. The GlideAggregate class works only on number fields. Since currency fields are strings, you can't use the GlideAggregate class on currency fields","!type":"fn(tableName: string)","prototype":{"next":{"!doc":"Moves to the next record in the GlideAggregate","!type":"fn() -> bool"},"getRowCount":{"!doc":"Retrieves the number of rows in the GlideRecord","!type":"fn() -> number"},"getAggregateEncodedQuery":{"!doc":"Gets the query necessary to return the current aggregate","!type":"fn() -> string"},"addAggregate":{"!doc":"Adds an aggregate","!type":"fn(aggregate: string, field: string)"},"query":{"!doc":"Issues the query and gets the results","!type":"fn()"},"getTableName":{"!doc":"Retrieves the table name associated with this GlideRecord","!type":"fn() -> string"},"orderBy":{"!doc":"Orders the aggregates using the value of the specified field. The field will also be added to the group-by list","!type":"fn(field: string)"},"orderByDesc":{"!doc":"Sorts the aggregates into descending order based on the specified field","!type":"fn(field: string)"},"hasNext":{"!doc":"Determines if there are any more results in the GlideAggregate","!type":"fn() -> bool"},"groupBy":{"!doc":"Provides the name of a field to use in grouping the aggregates. May be called numerous times to set multiple group fields","!type":"fn(field: string)"},"getEncodedQuery":{"!doc":"Retrieves the encoded query","!type":"fn() -> string"},"addNotNullQuery":{"!doc":"Adds a NOT NULL query to the aggregate","!type":"fn(field: string) -> +GlideQueryCondition"},"orderByAggregate":{"!doc":"Sorts the aggregates based on the specified aggregate and field","!type":"fn(aggregate: string, field: string)"},"addNullQuery":{"!doc":"Adds a NULL query to the aggregate","!type":"fn(field: string) -> +GlideQueryCondition"},"getValue":{"!doc":"Gets the value of a field","!type":"fn(field: string) -> string"},"setGroup":{"!doc":"Sets whether the results are to be grouped","!type":"fn(value: bool)"},"addEncodedQuery":{"!doc":"Adds a query to the aggregate. Adds an encoded query to the other queries that may have been set for this aggregate","!type":"fn(query: string)"},"addQuery":{"!doc":"Adds a query to the aggregate","!type":"fn(field: string, operator: string, value: string) -> +GlideQueryCondition"},"getAggregate":{"!doc":"Gets the value of the specified aggregate","!type":"fn(aggregate: string, field: string) -> string"}}},"sn_ws_err":{"":{"prototype":{}},"NotAcceptableError":{"!doc":"Sets status code 406 and includes the specified message in the response","!type":"fn(message: string)"},"ServiceError":{"!doc":"A generic error message wrapper to set status code and detailed error message in the response","!type":"fn()","prototype":{"setDetail":{"!doc":"The detailed error message","!type":"fn(detail: string)"},"setMessage":{"!doc":"The error message","!type":"fn(message: string)"},"setStatus":{"!doc":"The response status code -- defaults to 500","!type":"fn(code: number)"}}},"UnsupportedMediaTypeError":{"!doc":"Sets status code 415 and includes the specified message in the response","!type":"fn(message: string)"},"ConflictError":{"!doc":"Sets status code 409 and includes the specified message in the response","!type":"fn(message: string)"},"!doc":"Error types which can be set as the response body of a Scripted REST API","NotFoundError":{"!doc":"Sets status code 404 and includes the specified message in the response","!type":"fn(message: string)"},"BadRequestError":{"!doc":"Sets status code 400 and includes the specified message in the response","!type":"fn(message: string)"}},"GlideSession":{"!doc":"GlideSession manages all of the information for a user session. You can retrieve this from gs.getSession()","!type":"fn()","prototype":{"getTimeZoneName":{"!doc":"Get the Time Zone name associated with the user","!type":"fn() -> string"},"putClientData":{"!doc":"Store a value in an active session","!type":"fn(name: string, value: string)"},"getLanguage":{"!doc":"Language used by the user","!type":"fn() -> string"},"getUrlOnStack":{"!doc":"Gets the current URI for the session","!type":"fn() -> string"},"getClientData":{"!doc":"Fetch the value in active session based on the name","!type":"fn(name: string) -> string"},"isInteractive":{"!doc":"Checks if the current session is interactive","!type":"fn() -> bool"},"getClientIP":{"!doc":"Gets the client IP address","!type":"fn() -> string"},"isLoggedIn":{"!doc":"Determines if the current user is currently logged in","!type":"fn() -> bool"},"getCurrentApplicationId":{"!doc":"Gets the ID of current application, defined as a user preference and set by the application picker","!type":"fn() -> string"}}},"gs":{"monthsAgo":{"!doc":"Returns the (UTC) start of the quarter that was the specified number of months ago adjusted for the timezone of the server","!type":"fn(month: number) -> string"},"hoursAgoEnd":{"!doc":"Returns the (UTC) end of the hour that was the specified number of hours ago adjusted for the timezone of the server","!type":"fn(hours: number) -> string"},"endOfThisMonth":{"!doc":"Gets the date and time for the end of this month in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"isInteractive":{"!doc":"Checks if the current session is interactive","!type":"fn() -> bool"},"daysAgoEnd":{"!doc":"Returns the (UTC) end of the day that was the specified number of days ago adjusted for the timezone of the server","!type":"fn(daysAgo: number) -> string"},"beginningOfNextMonth":{"!doc":"Gets the date and time for the beginning of next month in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"hoursAgo":{"!doc":"number of hours ago","!type":"fn(hours: number) -> string"},"quartersAgoEnd":{"!doc":"Returns the (UTC) end of the quarter that was the specified number of quarters ago adjusted for the timezone of the server","!type":"fn(quarters: number) -> string"},"beginningOfThisYear":{"!doc":"Gets the date and time for the beginning of this year in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"getCurrentApplicationId":{"!doc":"Gets the ID of current application, defined as a user preference and set by the application picker","!type":"fn() -> string"},"endOfLastYear":{"!doc":"Gets the date and time for the end of last year in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"endOfNextYear":{"!doc":"Gets the date and time for the end of next year in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"nil":{"!doc":"Queries an object and returns true if the object is null, undefined, or contains an empty string","!type":"fn(o: Object) -> bool"},"beginningOfThisQuarter":{"!doc":"Gets the date and time for the beginning of this quarter in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"isDebugging":{"!doc":"Determines if debugging is active for a specific scope","!type":"fn() -> bool"},"setRedirect":{"!doc":"Set the redirect URI for this transaction. This determines the next page the user will see","!type":"fn(url: string)"},"datePart":{"!doc":"Returns a String of the form :interval,value,operator","!type":"fn(interval: string, value: string, operator: string) -> string"},"generateGUID":{"!doc":"Generates a GUID that can be used when a unique identifier is required","!type":"fn(obj: Object) -> string"},"getNewAppScopeCompanyPrefix":{"!doc":"","!type":"fn() -> string"},"getUserName":{"!doc":"Gets the username, or User ID, of the current user (e.g., abel.tuter)","!type":"fn() -> string"},"info":{"!doc":"Uses the info level to log a message to the system log","!type":"fn(message: string, parm1: Object, parm2: Object, parm3: Object, parm4: Object, parm5: Object)"},"base64Encode":{"!doc":"","!type":"fn(s: string) -> string"},"getUrlOnStack":{"!doc":"Gets the current URI for the session","!type":"fn() -> string"},"monthsAgoStart":{"!doc":"Returns the (UTC) start of the quarter that was the specified number of months ago adjusted for the timezone of the server","!type":"fn(month: number) -> string"},"getCssCacheVersionString":{"!doc":"Gets a string representing the cache version for a CSS file","!type":"fn() -> string"},"getCallerScopeName":{"!doc":"Gets the caller scope name, or returns null if there is no caller","!type":"fn() -> string"},"base64Decode":{"!doc":"","!type":"fn(s: string) -> string"},"minutesAgo":{"!doc":"number of minutes ago","!type":"fn(minutes: number) -> string"},"hoursAgoStart":{"!doc":"Returns the (UTC) start of the hour that was the specified number of hours ago adjusted for the timezone of the server","!type":"fn(hours: number) -> string"},"warn":{"!doc":"Uses the warn level to log a message to the system log","!type":"fn(message: string, parm1: Object, parm2: Object, parm3: Object, parm4: Object, parm5: Object)"},"endOfNextWeek":{"!doc":"Returns the (UTC) end of next week adjusted for the timezone of the server","!type":"fn() -> string"},"beginningOfLastWeek":{"!doc":"Gets the date and time for the beginning of last week in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"hasRole":{"!doc":"Determines if the current user has the specified role","!type":"fn(role: string) -> bool"},"isLoggedIn":{"!doc":"Determines if the current user is currently logged in","!type":"fn() -> bool"},"endOfThisWeek":{"!doc":"Gets the date and time for the end of this week in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"getUserDisplayName":{"!doc":"Gets the display name of the current user (e.g., Abel Tuter, as opposed to abel.tuter)","!type":"fn() -> string"},"beginningOfThisWeek":{"!doc":"Gets the date and time for the beginning of this week in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"getUser":{"!doc":"Returns a reference to the GlideUser object for the current user","!type":"fn() -> +GlideUser"},"urlDecode":{"!doc":"","!type":"fn(url: string) -> string"},"beginningOfLastYear":{"!doc":"Gets the date and time for the beginning of last year in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"tableExists":{"!doc":"Determines if a database table exists","!type":"fn(name: string) -> bool"},"error":{"!doc":"Uses the error level to log a message to the system log","!type":"fn(message: string, parm1: Object, parm2: Object, parm3: Object, parm4: Object, parm5: Object)"},"urlEncode":{"!doc":"","!type":"fn(url: string) -> string"},"endOfThisYear":{"!doc":"Gets the date and time for the end of this year in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"getCurrentScopeName":{"!doc":"Gets the name of the current scope","!type":"fn() -> string"},"yesterday":{"!doc":"Returns (UTC) 24 hours ago adjusted for the timezone of the current session","!type":"fn() -> string"},"daysAgoStart":{"!doc":"Returns the (UTC) start of the day that was the specified number of days ago adjusted for the timezone of the server","!type":"fn(daysAgo: number) -> string"},"beginningOfLastMonth":{"!doc":"Gets the date and time for the beginning of last month in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"beginningOfThisMonth":{"!doc":"Gets the date and time for the beginning of this month in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"beginningOfNextYear":{"!doc":"Gets the date and time for the beginning of next year in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"getDurationDate":{"!doc":"Returns the date of the duration time after January 1","!type":"fn(duration: string) -> string"},"addErrorMessage":{"!doc":"Adds an error message for the current session","!type":"fn(message: string)"},"beginningOfWeek":{"!doc":"Returns the (UTC) beginning of the specified week adjusted for the timezone of the current session","!type":"fn(o: Object) -> string"},"minutesAgoEnd":{"!doc":"Returns the (UTC) end of the minute that was the specified number of minutes ago adjusted for the timezone of the serve","!type":"fn(minutes: number) -> string"},"getSessionID":{"!doc":"Gets the GlideSession Session ID","!type":"fn() -> string"},"endOfNextMonth":{"!doc":"Gets the date and time for the end of next month in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"getUserID":{"!doc":"Gets the sys_id of the current user","!type":"fn() -> string"},"include":{"!doc":"Provides a safe way to call from the sandbox, allowing only trusted scripts to be included","!type":"fn(name: string) -> bool"},"daysAgo":{"!doc":"Returns the (UTC) start of the day that was the specified number of days ago adjusted for the timezone of the server","!type":"fn(days: number) -> string"},"minutesAgoStart":{"!doc":"Returns the (UTC) start of the minute that was the specified number of minutes ago adjusted for the timezone of the serve","!type":"fn(minutes: number) -> string"},"getProperty":{"!doc":"Retrieves a message from UI messages","!type":"fn(key: string, alt: Object) -> string"},"endOfWeek":{"!doc":"Returns the (UTC) end of the specified week adjusted for the timezone of the current session","!type":"fn(o: Object) -> string"},"endOfLastMonth":{"!doc":"Gets the date and time for the end of last month in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"debug":{"!doc":"Uses the debug level to log a message to the system log","!type":"fn(message: string, parm1: Object, parm2: Object, parm3: Object, parm4: Object, parm5: Object)"},"!doc":"The scoped GlideSystem (referred to by the variable name 'gs' in any server-side JavaScript) API provides a number of convenient methods to get information about the system, the current logged in user, etc.","getMessage":{"!doc":"Retrieves a message from UI messages. args is an optional paramter","!type":"fn(id: string, args: ?) -> string"},"endOfThisQuarter":{"!doc":"Gets the date and time for the end of this quarter in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"eventQueue":{"!doc":"Queues an event for the event manager","!type":"fn(name: string, record: +GlideRecord, parm1: string, parm2: string, queue: string)"},"xmlToJSON":{"!doc":"","!type":"fn(xmlString: string) -> +Object"},"addInfoMessage":{"!doc":"Adds an info message for the current session","!type":"fn(message: string)"},"beginningOfNextWeek":{"!doc":"Gets the date and time for the beginning of next week in UTC, adjusted for the timezone of the server","!type":"fn() -> string"},"getMaxSchemaNameLength":{"!doc":"","!type":"fn() -> number"},"endOfLastWeek":{"!doc":"Returns the (UTC) end of last week adjusted for the timezone of the server","!type":"fn() -> string"},"quartersAgoStart":{"!doc":"Returns the (UTC) start of the quarter that was the specified number of quarters ago adjusted for the timezone of the server","!type":"fn(quarters: number) -> string"},"getSession":{"!doc":"Gets a reference to the current Glide session","!type":"fn() -> +GlideSession"}},"GlideFilter":{"!doc":"The scoped GlideFilter class allows you to determine if a record meets a specified set of requirements. There is no constructor for scoped GlideFilter, it is accessed by using the global object 'GlideFilter'","checkRecord":{"!doc":"Returns true when the record meets the filter condition","!type":"fn(gr: +GlideRecord, filter: string, value: bool) -> bool"},"!type":"fn()"},"GlideDate":{"!doc":"The scoped GlideDate class provides methods for performing operations on GlideDate objects, such as instantiating GlideDate objects or working with GlideDate fields","!type":"fn()","prototype":{"getByFormat":{"!doc":"Gets the date in the given date format","!type":"fn(format: string) -> string"},"getMonthNoTZ":{"!doc":"Returns the month part of a date with no timezone conversion","!type":"fn() -> number"},"getValue":{"!doc":"Gets the date value stored in the database by the GlideDate object in the internal format, yyyy-MM-dd, and the system time zone, UTC by default","!type":"fn() -> string"},"getYearNoTZ":{"!doc":"Returns the year part of a date with no timezone conversion","!type":"fn() -> number"},"subtract":{"!doc":"Gets the duration difference between two GlideDate values","!type":"fn(start: +GlideDate, end: +GlideDate) -> +GlideDuration"},"getDisplayValue":{"!doc":"Gets the date in the current user's display format and time zone","!type":"fn() -> string"},"setValue":{"!doc":"Sets the date of the GlideDate object","!type":"fn(o: ?)"},"getDisplayValueInternal":{"!doc":"Gets the display value in the internal format (yyyy-MM-dd). Note: This method is useful for date or time fields, but not date fields","!type":"fn() -> string"},"getDayOfMonthNoTZ":{"!doc":"Returns the day part of a date with no timezone conversion","!type":"fn() -> number"},"setDisplayValue":{"!doc":"Sets a date value using the current user's display format and time zone","!type":"fn(asDisplayed: string)"}}},"GlideScriptedProcessor":{"!doc":"ServiceNow processors are equivalent to Java servlets. Processors provide a customizable URL endpoint that can execute arbitrary server-side Javascript code and produce output such as TEXT, JSON, or HTML. The GlideScriptedProcessor APIs are used in processor scripts to access the the processor (servlet) capabilities. There are no constructors for the GlideScriptedProcessor APIs. The methods are called using the global variable g_processor. A useful global variable, g_target, is available in processor scripts. It contains the table name extracted from the URL. The URL to a processor has the format: https://<instance name.servicenow.com>/<path endpoint>.do?<parameter endpoint>=<value> where the path endpoint and parameter endpoint are defined on the processor form","!type":"fn()","prototype":{"redirect":{"!doc":"Redirects to the specified URL","!type":"fn(url: string)"},"writeOutput":{"!doc":"Writes the contents of the given string to the response","!type":"fn(contentType: string, value: string)"},"writeJSON":{"!doc":"Writes a JSON object to the current URL. Note: Works only in scoped apps","!type":"fn(jsonObject: ?)"}}},"sn_ws_int":{"":{"prototype":{}},"WSSoapRequestDocument":{"!doc":"SOAP request object as a DOM Document or XMLDocument2 (for new application scope)","!type":"Object"},"!doc":"These objects are relevant to Scripted REST APIs and are accessed via the request or response input parameters to Scripted APIs","RESTAPIResponseStream":{"!doc":"Allows you to write streams or strings directly to the response stream in a Scripted REST API","!type":"fn()","prototype":{"writeStream":{"!doc":"Write an InputStream directly to the response stream. Can be called multiple times. Caller responsible for response format and setting proper Content-Type and status code prior to calling","!type":"fn(inputStream: Object)"},"writeString":{"!doc":"Write a string directly to the response stream. Can be called multiple times. Caller responsible for response format and setting proper Content-Type and status code prior to calling","!type":"fn(stringToWrite: string)"}}},"RESTAPIResponse":{"!doc":"Allows you to configure the HTTP response in Scripted REST APIs","!type":"fn()","prototype":{"setHeaders":{"!doc":"Set response headers from the specified object","!type":"fn(headers: ?)"},"getStreamWriter":{"!doc":"Return stream writer. Caller responsible to set proper content type and status using setStatus and setHeader methods. Caller responsible to populate all headers on response before actually writing to stream","!type":"fn() -> +sn_ws_int.RESTAPIResponseStream"},"setLocation":{"!doc":"Set the Location header","!type":"fn(locationValue: string)"},"setError":{"!doc":"Set Response Error","!type":"fn(error: ?)"},"setContentType":{"!doc":"Set the Content-Type header","!type":"fn(contentType: string)"},"setBody":{"!doc":"Use the specified object as the response body","!type":"fn(body: ?)"},"setStatus":{"!doc":"Set response HTTP status code","!type":"fn(code: number)"},"setHeader":{"!doc":"Set a response header","!type":"fn(name: string, value: string)"}}},"WSRequest":{"!doc":"Provides access to request input parameters","!type":"fn()","prototype":{"<input parameter name>":{"!doc":"Use request.<parameter name> to get the value of an input parameter"}}},"WSResponse":{"!doc":"Allows setting response output parameters","!type":"fn()","prototype":{"<output parameter name>":{"!doc":"Use response.<parameter name> to assign a value to an output parameter"},"soapResponseElement":{"!doc":"Use this variable to assign a response value as a DOM Element"}}},"WSSoapRequestXML":{"!doc":"SOAP request object as a String","!type":"string"},"RESTAPIRequest":{"!doc":"Allows you to access request details in Scripted REST APIs","!type":"fn()","prototype":{"headers":{"!doc":"All headers from the request"},"pathParams":{"!doc":"The variable path parameters passed in the request URI as an object"},"queryParams":{"!doc":"The query parameters from the request as an object"},"getRequestedQueryCategory":{"!doc":"Get the query category (i.e. read replica category) from query parameter 'sysparm_query_category'","!type":"fn() -> string"},"getSupportedResponseContentTypes":{"!doc":"Obtain a set of media types that are common between what the client request accepts and what this service is able to produce","!type":"fn() -> Object"},"body":{"!doc":"The body of the request","!type":"+sn_ws_int.RESTAPIRequestBody"},"queryString":{"!doc":"The entire query string from the request URI","!type":"string"},"uri":{"!doc":"The request URI, excluding domain information","!type":"string"},"url":{"!doc":"The entire request URL, including domain","!type":"string"},"getHeader":{"!doc":"Get the value of a specific header from the request","!type":"fn(headerName: string) -> string"}}},"RESTAPIRequestBody":{"!doc":"Allows you to access the request body as a stream, as a string, de-serialized into an object, or as an array of obects","!type":"fn()","prototype":{"nextEntry":{"!doc":"Returns the next entry from the request body as an object if request is array. If not an array then returns entire request body as an object","!type":"fn() -> Object"},"data":{"!doc":"The request body de-serialized as an object"},"dataString":{"!doc":"The request body as a string -- be careful to consider impact to memory","!type":"string"},"dataStream":{"!doc":"The body of the request as a stream. Note, this object provides no functions to manipulate the stream from script. Rather this object can be passed to another API which takes an InputStream as an input parameter","!type":"+GlideScriptableInputStream"},"hasNext":{"!doc":"Return true if request has more entries. Use this in conjunction with nextEntry","!type":"fn() -> bool"}}}},"GlideTime":{"!doc":"The scoped GlideTime class provides methods for performing operations on GlideTime objects, such as instantiating GlideTime objects or working with GlideTime fields","!type":"fn()","prototype":{"getByFormat":{"!doc":"Gets the time in the given time format","!type":"fn(format: string) -> string"},"subtract":{"!doc":"Gets the duration difference between two GlideTime values","!type":"fn(start: +GlideTime, end: +GlideTime) -> +GlideDuration"},"getHourLocalTime":{"!doc":"Returns hour part of local time 0-11","!type":"fn() -> number"},"setDisplayValue":{"!doc":"Sets a time value using the current user's display format and time zone","!type":"fn(asDisplayed: string)"},"getHourUTC":{"!doc":"Returns hour part of UTC time 0-11","!type":"fn() -> number"},"getValue":{"!doc":"Gets the time value stored in the database by the GlideTime object in the internal format, HH:mm:ss, and the system time zone, UTC by default","!type":"fn() -> string"},"getMinutesUTC":{"!doc":"Returns minutes part of UTC time","!type":"fn() -> number"},"getSeconds":{"!doc":"Returns seconds part of time","!type":"fn() -> number"},"getDisplayValue":{"!doc":"Gets the time in the current user's display format and time zone","!type":"fn() -> string"},"setValue":{"!doc":"Sets the time of the GlideTime object in the internal time zone, which is UTC by default or the value of the glide.sys.internal.tz property, if set","!type":"fn(value: ?)"},"getDisplayValueInternal":{"!doc":"Gets the display value in the current user's time zone and the internal format (HH:mm:ss). Useful for date/time fields, but not for date fields","!type":"fn() -> string"},"getHourOfDayLocalTime":{"!doc":"Returns hour-of-the-day part of local time 0-23","!type":"fn() -> number"},"getHourOfDayUTC":{"!doc":"Returns the hour-of-the-day part of UTC time 0-23","!type":"fn() -> number"},"getMinutesLocalTime":{"!doc":"Returns minutes part of local time","!type":"fn() -> number"}}},"GlideUser":{"!doc":"The Scoped GlideUser API provides access to information about the current user and current user roles. Using the Scoped GlideUser API avoids the need to use the slower GlideRecord queries to get user information","!type":"fn()","prototype":{"getName":{"!doc":"Gets the user id, or login name, of the current user","!type":"fn() -> string"},"getDisplayName":{"!doc":"Gets the display name of the current user","!type":"fn() -> string"},"getCompanyID":{"!doc":"Gets the Company ID of the current user","!type":"fn() -> string"},"hasRole":{"!doc":"Determines if the current user has the specified role","!type":"fn(role: string) -> bool"},"getID":{"!doc":"Gets the sys_id of current user","!type":"fn() -> string"},"isMemberOf":{"!doc":"Determines if the current user is a member of the specified group","!type":"fn(group: string) -> bool"},"savePreference":{"!doc":"Saves a user preference value to the database","!type":"fn(name: string, value: string)"},"getPreference":{"!doc":"Gets the specified user preference value for the current user","!type":"fn(name: string) -> string"}}},"GlideSchedule":{"!doc":"The scoped GlideSchedule API provides methods for performing operations on GlideSchedule objects, such as adding new schedule segments to a schedule, determining if a datetime is within the schedule, or setting the schedule timezone","!type":"fn()","prototype":{"add":{"!doc":"Adds a new schedule segment to the current schedule","!type":"fn(startDate: +GlideDateTime, offset: +GlideDuration) -> GlideDateTime"},"duration":{"!doc":"Determines the elapsed time in the schedule between two date time values using the timezone of the schedule or, if that is not specified, the timezone of the session","!type":"fn(startDate: +GlideDateTime, endDate: +GlideDateTime) -> +GlideDuration"},"getName":{"!doc":"Gets the current schedule name","!type":"fn() -> string"},"load":{"!doc":"Loads a schedule with the schedule information. If a timezone is not specified or is nil, the current session timezone is used for the schedule","!type":"fn(sysID: string, timeZone: string, excludeSpanID: string)"},"isValid":{"!doc":"Determines if the current schedule is valid. A schedule is valid if it has at least one schedule span","!type":"fn() -> bool"},"setTimeZone":{"!doc":"Sets the timezone for the current schedule","!type":"fn(tz: string)"}}},"GlideElement":{"!doc":"The Scoped GlideElement API provides methods for dealing with fields and their values. Scoped GlideElement methods are available for the fields of the current GlideRecord","!type":"fn()","prototype":{"getCurrencyCode":{"!doc":"Gets the currency ISO code for a record","!type":"fn() -> string"},"getLabel":{"!doc":"Gets the object's label","!type":"fn() -> string"},"getName":{"!doc":"Gets the name of the field","!type":"fn() -> string"},"getBooleanAttribute":{"!doc":"Gets the value of the attribute on the field in question from the dictionary as a string. To get the value as a string, use getAttribute(string)","!type":"fn(attribute: string) -> bool"},"canRead":{"!doc":"Determines if the GlideRecord table can be read from","!type":"fn() -> bool"},"changes":{"!doc":"Determines if the current field has been modified","!type":"fn() -> bool"},"getReferenceDisplayValue":{"!doc":"Gets the display value","!type":"fn() -> string"},"getCurrencyString":{"!doc":"Gets currency in a string","!type":"fn() -> string"},"getReferenceTable":{"!doc":"Gets table name for a reference field","!type":"fn() -> string"},"getReferenceValue":{"!doc":"Gets the reference value","!type":"fn() -> string"},"nil":{"!doc":"Determines whether the field is null","!type":"fn() -> bool"},"getSessionDisplayValue":{"!doc":"Gets the currency value in the sessions currency format","!type":"fn() -> string"},"getDecryptedValue":{"!doc":"Gets the decrypted value","!type":"fn() -> string"},"getAttribute":{"!doc":"Gets the value of the attribute on the field in question from the dictionary as a string. If the attribute is a boolean attribute, use getBooleanAttribute(String) to get the value as a boolean rather than as a string","!type":"fn(attribute: string) -> string"},"getCurrencyDisplayValue":{"!doc":"Gets the currency display value","!type":"fn() -> string"},"getSessionCurrencyCode":{"!doc":"Gets the sessions currency ISO code","!type":"fn() -> string"},"getCurrencyValue":{"!doc":"Gets a currency value","!type":"fn() -> string"},"getReferenceCurrencyCode":{"!doc":"The currency ISO code, in the base system currency","!type":"fn() -> string"},"changesTo":{"!doc":"Determines if the new value of a field after a change matches a certain object","!type":"fn(value: ?) -> bool"},"getChoices":{"!doc":"Retrieves the choice list for a field","!type":"fn(dependent: string) -> []"},"getTableName":{"!doc":"Gets the table name","!type":"fn() -> string"},"hasAttribute":{"!doc":"Determines whether a field has a particular attribute","!type":"fn(attribute: string) -> bool"},"setDateNumericValue":{"!doc":"Sets a date to a numeric value","!type":"fn(value: ?)"},"setDisplayValue":{"!doc":"Sets the display value of the field","!type":"fn(value: ?)"},"getRefRecord":{"!doc":"Gets a GlideRecord object for a reference element","!type":"fn() -> +GlideRecord"},"canWrite":{"!doc":"Determines if the GlideRecord table can be written to","!type":"fn() -> bool"},"changesFrom":{"!doc":"Determines the previous value of the current field matched a certain object","!type":"fn(value: ?) -> bool"},"canCreate":{"!doc":"Determines if the user's role permits creation of new records in this field","!type":"fn() -> bool"},"getED":{"!doc":"Gets the field's element descriptor","!type":"fn() -> +GlideElementDescriptor"},"getSessionValue":{"!doc":"Gets the ammount in the sessions currency","!type":"fn() -> string"},"dateNumericValue":{"!doc":"Gets date in numberic value","!type":"fn(value: string) -> number"},"setError":{"!doc":"Adds an error message. Can be retrieved using getError()","!type":"fn(message: string)"},"setValue":{"!doc":"Sets the display value of the field","!type":"fn(value: ?)"},"getDisplayValue":{"!doc":"Gets the formatted display value of the field","!type":"fn(maxCharacters: number) -> string"},"toString":{"!doc":"Converts the value to a string","!type":"fn() -> string"}}},"GlideDateTime":{"!doc":"The scoped GlideDateTime default constructor, instantiates a new GlideDateTime object with the current date and time in Greenwich Mean Time (GMT). Optional 'value' parameter with a date and time value in the UTC time zone specified with the format yyyy-MM-dd HH:mm:ss","!type":"fn(value: string)","prototype":{"getDayOfWeekLocalTime":{"!doc":"Gets the day of the week stored by the GlideDateTime object, expressed in the user's time zone","!type":"fn() -> number"},"before":{"!doc":"Returns true if the object's data time is before the input argument","!type":"fn(object: +GlideDateTime) -> bool"},"addWeeksUTC":{"!doc":"Adds a specified number of weeks to the current GlideDateTime object, expressed in the UTC time zone","!type":"fn(amount: number)"},"getDaysInMonthLocalTime":{"!doc":"Sets the day of the month to a specified value in the user's time zone","!type":"fn() -> number"},"setMonthUTC":{"!doc":"Sets the month stored by the GlideDateTime object to a specified value using the UTC time zone","!type":"fn(month: number)"},"compareTo":{"!doc":"Compares two GlideDateTime objects","!type":"fn(object: +GlideDateTime) -> number"},"setGlideDateTime":{"!doc":"Sets the date and time of the current object using an existing GlideDateTime object. This method is equivalent to instantiating a new object with a GlideDateTime parameter","!type":"fn(gdt: +GlideDateTime)"},"setMonthLocalTime":{"!doc":"Sets the month stored by the GlideDateTime object to a specified value using the current user's time zone","!type":"fn(month: number)"},"getMonthLocalTime":{"!doc":"Gets the month stored by the GlideDateTime object, expressed in the current user's time zone","!type":"fn() -> number"},"getLocalDate":{"!doc":"Gets the date for the user's time zone","!type":"fn() -> +GlideDate"},"setYearUTC":{"!doc":"Sets the year stored by the GlideDateTime object to a specified value using the UTC time zone","!type":"fn(year: number)"},"getDayOfWeekUTC":{"!doc":"Gets the day of the week stored by the GlideDateTime object, expressed in the UTC time zone","!type":"fn() -> number"},"getWeekOfYearUTC":{"!doc":"Gets the number of the current week of the current year","!type":"fn() -> number"},"setDayOfMonthLocalTime":{"!doc":"Sets the day of the month to a specified value in the local time zone","!type":"fn(day: number)"},"addYearsUTC":{"!doc":"Adds a specified number of years to the current GlideDateTime object, expressed in the UTC time zone","!type":"fn(amount: number)"},"onOrAfter":{"!doc":"Returns true if the object's data time is on or after the input argument","!type":"fn(object: +GlideDateTime) -> bool"},"add":{"!doc":"Adds a GlideTime object to the current GlideDateTime object","!type":"fn(gt: +GlideTime)"},"getInternalFormattedLocalTime":{"!doc":"Returns local time with internal time format","!type":"fn() -> string"},"subtract":{"!doc":"Gets the duration difference between two GlideDateTime values. Pass a single paramter which specifies milliseconds to subtract from the current GlideDateTime object","!type":"fn(start: +GlideDateTime, end: +GlideDateTime) -> +GlideDuration"},"getWeekOfYearLocalTime":{"!doc":"Gets the number of the week stored by the GlideDateTime object, expressed in the user's time zone","!type":"fn() -> number"},"getDisplayValueWithoutTZ":{"!doc":"","!type":"fn() -> string"},"setDisplayValue":{"!doc":"Sets a date and time value using the current user's display format and time zone. Also set an optional parameter 'format', to set date and time format","!type":"fn(value: string, format: string)"},"getUserFormattedLocalTime":{"!doc":"Returns local time with user time format","!type":"fn() -> string"},"getMonthUTC":{"!doc":"Gets the month stored by the GlideDateTime object, expressed in the UTC time zone","!type":"fn() -> number"},"addSeconds":{"!doc":"Adds a specified number of seconds to the current GlideDateTime object","!type":"fn(value: number)"},"getDaysInMonthUTC":{"!doc":"Gets the number of days in the month stored by the GlideDateTime object, expressed in the UTC time zone","!type":"fn() -> number"},"getLocalTime":{"!doc":"Returns a GlideTime object that represents the time portion of the GlideDateTime object in the user's time zone","!type":"fn() -> +GlideTime"},"addYearsLocalTime":{"!doc":"Adds a specified number of years to the current GlideDateTime object, expressed in the user's time zone","!type":"fn(amount: number)"},"getYearLocalTime":{"!doc":"Gets the year stored by the GlideDateTime object, expressed in the current user's time zone","!type":"fn() -> number"},"getDayOfMonthUTC":{"!doc":"Gets the day of the month stored by the GlideDateTime object, expressed in the UTC time zone","!type":"fn() -> number"},"getNumericValue":{"!doc":"Gets the number of milliseconds since January 1, 1970, 00:00:00 Greenwich Mean Time (GMT)","!type":"fn() -> number"},"getTime":{"!doc":"Returns a GlideTime object that represents the time portion of the GlideDateTime object","!type":"fn() -> +GlideTime"},"isDST":{"!doc":"Determines if an object's time uses a daylight savings offset","!type":"fn() -> bool"},"addMonthsUTC":{"!doc":"Adds a specified number of months to the current GlideDateTime object, expressed in the UTC time zone","!type":"fn(amount: number)"},"addDaysLocalTime":{"!doc":"Adds a specified number of days to the current GlideDateTime object, expressed in the user's timezone","!type":"fn(amount: number)"},"getDSTOffset":{"!doc":"Gets the amount of time that daylight savings time is offset","!type":"fn() -> number"},"hashCode":{"!doc":"","!type":"fn() -> number"},"addMonthsLocalTime":{"!doc":"Adds a specified number of months to the current GlideDateTime object, expressed in the user's time zone","!type":"fn(amount: number)"},"getDisplayValueInternal":{"!doc":"Gets the display value in the internal datetime format","!type":"fn() -> string"},"getDayOfMonthLocalTime":{"!doc":"Gets the day of the month stored by the GlideDateTime object, expressed in the current user's time zone","!type":"fn() -> number"},"getDate":{"!doc":"Gets the date in the system time zone","!type":"fn() -> +GlideDate"},"after":{"!doc":"Returns true if the object's data time is after the input argument","!type":"fn(object: +GlideDateTime) -> bool"},"getErrorMsg":{"!doc":"Gets the current error message","!type":"fn() -> string"},"getTZOffset":{"!doc":"","!type":"fn() -> number"},"setDisplayValueInternal":{"!doc":"Sets a date and time value using the internal format and the current user's time zone","!type":"fn(value: string)"},"onOrBefore":{"!doc":"Returns true if the object's data time is on or before the input argument","!type":"fn(object: +GlideDateTime) -> bool"},"setDayOfMonthUTC":{"!doc":"Sets the day of the month to a specified value in the UTC time zone","!type":"fn(day: number)"},"isValid":{"!doc":"Determines if a value is a valid datetime","!type":"fn() -> bool"},"hasDate":{"!doc":"Determines if an object's date is set","!type":"fn() -> bool"},"setYearLocalTime":{"!doc":"Sets the year stored by the GlideDateTime object to a specified value using the current user's time zone","!type":"fn(year: number)"},"setValueUTC":{"!doc":"Sets a date and time value using the UTC time zone and the specified date and time format","!type":"fn(dt: string, format: string)"},"getValue":{"!doc":"Gets a datetiime value in the same format as it is stored in the database","!type":"fn() -> string"},"getYearUTC":{"!doc":"Gets the year stored by the GlideDateTime object, expressed in the UTC time zone","!type":"fn() -> number"},"equals":{"!doc":"","!type":"fn(object: +GlideDateTime) -> bool"},"getDisplayValue":{"!doc":"Gets the datetime in the current user's display format and time zone","!type":"fn() -> string"},"setValue":{"!doc":"Sets the date and time","!type":"fn(value: number)"},"toString":{"!doc":"Converts a datetime value to a string","!type":"fn() -> string"},"addDaysUTC":{"!doc":"Adds a specified number of days to the current GlideDateTime object, expressed in the UTC time zone","!type":"fn(amount: number)"},"addWeeksLocalTime":{"!doc":"Adds a specified number of weeks to the current GlideDateTime object, expressed in the user's timezone","!type":"fn(amount: number)"}}},"GlideDBFunctionBuilder":{"!doc":"The Scoped GlideDBFunctionBuilder provides a builder API for creating platform function definition","!type":"fn()","prototype":{"add":{"!doc":"Start an addition function","!type":"fn() -> +GlideDBFunctionBuilder"},"constant":{"!doc":"Add a constant parameter to the current function","!type":"fn(constant: string) -> +GlideDBFunctionBuilder"},"endfunc":{"!doc":"End the current function","!type":"fn() -> +GlideDBFunctionBuilder"},"subtract":{"!doc":"Start a subtraction function","!type":"fn() -> +GlideDBFunctionBuilder"},"length":{"!doc":"Start a length function","!type":"fn() -> +GlideDBFunctionBuilder"},"concat":{"!doc":"Start a concatenation function","!type":"fn() -> +GlideDBFunctionBuilder"},"datediff":{"!doc":"Start a function that return the duration between 2 dates","!type":"fn() -> +GlideDBFunctionBuilder"},"field":{"!doc":"Add a field parameter to the current function","!type":"fn(fieldName: string) -> +GlideDBFunctionBuilder"},"build":{"!doc":"Return the completed function definition","!type":"fn() -> string"},"now":{"!doc":"Start a function that returns the current timestamp in the UTC timezone. This function should be used as a parameter to the datediff function to calculate a duration between the current datetime and another datetime field or datetime constant","!type":"fn() -> +GlideDBFunctionBuilder"},"dayofweek":{"!doc":"Start a function that returns the day of the week of a given date","!type":"fn() -> +GlideDBFunctionBuilder"},"divide":{"!doc":"Start a division function","!type":"fn() -> +GlideDBFunctionBuilder"},"multiply":{"!doc":"Start a multiplication function","!type":"fn() -> +GlideDBFunctionBuilder"}}},"sn_clotho":{"":{"prototype":{}},"TransformResult":{"!doc":"An object that contains a transform execution result","!type":"fn()","prototype":{"getByLabel":{"!doc":"Returns a series with the specified label","!type":"fn(label: string) -> +sn_clotho.Data"},"byGroup":{"!doc":"Returns a mapping of group names to their series","!type":"fn() -> +map"},"toArray":{"!doc":"Returns the all series of this TransformResult in the form of an array","!type":"fn() -> [+sn_clotho.Data]"},"getData":{"!doc":"Returns this result's series, assuming that there is a single resultant series","!type":"fn() -> +sn_clotho.Data"}}},"Transformer":{"!doc":"Instantiates a MetricBase transformer for the specified GlideRecord","!type":"fn(gr: +GlideRecord)","prototype":{"metric":{"!doc":"Specifies the metric field that this transformer operates on","!type":"fn(metricName: string) -> +sn_clotho.TransformPart"},"groupBy":{"!doc":"Groups the subject records by the specified field","!type":"fn(field: string) -> +sn_clotho.TransformPart"},"execute":{"!doc":"Executes the transforms defined by this transformer over the specified time range and returns an object containing the results","!type":"fn(rangeStart: +GlideDateTime, rangeEnd: +GlideDateTime) -> +sn_clotho.TransformResult"}}},"DataBuilder":{"!doc":"Builds data to put into MetricBase","!type":"fn(cx: Context, args: [object], ctorObj: Function, inNewExpr: boolean)","prototype":{"add":{"!doc":"Adds the specified value to the data at the specified time","!type":"fn(start: +GlideDateTime, value: number) -> +sn_clotho.DataBuilder"}}},"!doc":"MetricBase JavaScript API","TransformPart":{"!doc":"Defines a transformer's transforms","!type":"fn()","prototype":{"sub":{"!doc":"Subtracts the specified constant quantity from all values","!type":"fn(substrahend: number) -> +sn_clotho.TransformPart"},"mul":{"!doc":"Multiplies all values by the specified constant quantity","!type":"fn(factor: number) -> +sn_clotho.TransformPart"},"log":{"!doc":"Performs a logarithm on all values with the specified constant base","!type":"fn(base: number) -> +sn_clotho.TransformPart"},"sum":{"!doc":"Produces a new series where each value is the sum of all of the values at each timestamp","!type":"fn() -> +sn_clotho.TransformPart"},"groupBy":{"!doc":"Groups the subject records by the specified field","!type":"fn(field: string) -> +sn_clotho.TransformPart"},"div":{"!doc":"Divides all values by the specified constant quantity","!type":"fn(divisor: number) -> +sn_clotho.TransformPart"},"fit":{"!doc":"Fits the series to the specified model using the specified parameters","!type":"fn(_params: object) -> +sn_clotho.TransformPart"},"avg":{"!doc":"Produces a new series where each value is the average of all of the values at each timestamp","!type":"fn() -> +sn_clotho.TransformPart"},"min":{"!doc":"Produces a new series with the smallest values at each timestamp","!type":"fn() -> +sn_clotho.TransformPart"},"partition":{"!doc":"Produces a new series with the values filtered (AVG, MAX, MIN or LAST) by non-overlapping windows","!type":"fn(_aggregator: string, _window: string, _base: string) -> +sn_clotho.TransformPart"},"top":{"!doc":"Produces a set of series with the top 'count' (specified) largest values at each timestamp","!type":"fn(count: number) -> +sn_clotho.TransformPart"},"limit":{"!doc":"Limits the number of data points in each series to the specified count","!type":"fn(count: number) -> +sn_clotho.TransformPart"},"where":{"!doc":"Produces a set of new series by specified condition","!type":"fn(condition: Condition) -> +sn_clotho.TransformPart"},"stddev":{"!doc":"Produces a new series with the standard deviation of the values at each timestamp","!type":"fn() -> +sn_clotho.TransformPart"},"floor":{"!doc":"Floors all values to the specified precision","!type":"fn(precision: number) -> +sn_clotho.TransformPart"},"fractiles":{"!doc":"Produces a set of series where each is one of the specified percentiles of all of the data","!type":"fn(fractions: [number]) -> +sn_clotho.TransformPart"},"add":{"!doc":"Adds the specified constant quantity to all values","!type":"fn(summand: number) -> +sn_clotho.TransformPart"},"max":{"!doc":"Produces a new series with the largest values at each timestamp","!type":"fn() -> +sn_clotho.TransformPart"},"bottom":{"!doc":"Produces a set of series with the bottom 'count' (specified) smallest values at each timestamp","!type":"fn(count: number) -> +sn_clotho.TransformPart"},"count":{"!doc":"Produces a new series that counts the number of series with values in the input","!type":"fn() -> +sn_clotho.TransformPart"},"interpolate":{"!doc":"Populates missing (NaN) values with two-point linear regression using the specified tolerance for maximum range of missing data","!type":"fn(countOrDuration: object) -> +sn_clotho.TransformPart"},"label":{"!doc":"Labels this series","!type":"fn(label: string) -> +sn_clotho.TransformPart"},"ceil":{"!doc":"Ceils all values to the specified precision","!type":"fn(precision: number) -> +sn_clotho.TransformPart"},"filter":{"!doc":"Produces a new series with the values filtered (AVG, MAX, MIN or LAST) by sliding windows","!type":"fn(_aggregator: string, _window: string) -> +sn_clotho.TransformPart"},"median":{"!doc":"Produces a new series with the median of the values at each timestamp","!type":"fn() -> +sn_clotho.TransformPart"},"round":{"!doc":"Rounds all values to the specified precision","!type":"fn(precision: number) -> +sn_clotho.TransformPart"},"metric":{"!doc":"Specifies the metric field that this transformer operates on","!type":"fn(metricName: string) -> +sn_clotho.TransformPart"},"collect":{"!doc":"Includes this intermediate transform as part of the result","!type":"fn() -> +sn_clotho.TransformPart"},"resample":{"!doc":"Aligns all series to have the specified number of data points","!type":"fn(numValues: number) -> +sn_clotho.TransformPart"}}},"Data":{"!doc":"Stores a single series of MetricBase data","!type":"fn()","prototype":{"getSubject":{"!doc":"Returns the value of the subject this series operates on","!type":"fn() -> string"},"fromModelString":{"!doc":"Converts the specified model string into a series","!type":"fn(model: string) -> +sn_clotho.Data"},"getLabel":{"!doc":"Returns the label of this series","!type":"fn() -> string"},"getStart":{"!doc":"Returns the start time of this series","!type":"fn() -> +GlideDateTime"},"size":{"!doc":"Returns the number of values in this series","!type":"fn() -> number"},"getValues":{"!doc":"Returns the values in this series in the form of an array of numbers","!type":"fn() -> [number]"},"getTableName":{"!doc":"Returns the name of the table this series operates on","!type":"fn() -> string"},"getMetricName":{"!doc":"Returns the name of the metric this series operates on","!type":"fn() -> string"},"toModelString":{"!doc":"Converts this series into a model string","!type":"fn() -> string"},"getEnd":{"!doc":"Returns the end time of this series","!type":"fn() -> +GlideDateTime"},"getPeriod":{"!doc":"Returns the period of this series","!type":"fn() -> number"}}},"Client":{"!doc":"Interacts with the MetricBase database","!type":"fn()","prototype":{"transform":{"!doc":"Performs the specified transform(s) over the specified range","!type":"fn(o1: object, o2: +GlideDateTime, o3: +GlideDateTime) -> object"},"put":{"!doc":"Uses the specified DataBuilder to put data into MetricBase","!type":"fn(dataBuilder: +sn_clotho.DataBuilder)"}}}},"GlideLocale":{"!doc":"GlideLocale is a global object that can be called in scripts. Use the get() method to get a GlideLocale object","get":{"!doc":"Returns the GlideLocale object","!type":"fn() -> +GlideLocale"},"!type":"fn()","prototype":{"getGroupingSeparator":{"!doc":"Returns the decimal separator","!type":"fn() -> string"},"getDecimalSeparator":{"!doc":"Returns the grouping separator","!type":"fn() -> string"}}},"XMLNodeIterator":{"!doc":"The scoped XMLNodeIterator class allows you to iterate through a node of a XML document","!type":"fn()","prototype":{"next":{"!doc":"Gets the next element in the iteration","!type":"fn() -> +XMLNode"},"hasNext":{"!doc":"Determines if the iteration has more elements","!type":"fn() -> bool"}}}}}}
{ result:
   { catalog_client_script:
      { GlideServletRequest: [Object],
        XMLNode: [Object],
        GlideScopedEvaluator: [Object],
        GlideTableHierarchy: [Object],
        GlidePluginManager: [Object],
        sn_auth: [Object],
        GlideRecord: [Object],
        sn_ws: [Object],
        GlideServletResponse: [Object],
        GlideElementDescriptor: [Object],
        GlideQueryCondition: [Object],
        GlideScriptableInputStream: [Object],
        GlideRecordSecure: [Object],
        XMLDocument2: [Object],
        GlideDuration: [Object],
        GlideAggregate: [Object],
        sn_ws_err: [Object],
        GlideSession: [Object],
        gs: [Object],
        GlideFilter: [Object],
        GlideDate: [Object],
        GlideScriptedProcessor: [Object],
        sn_ws_int: [Object],
        GlideTime: [Object],
        GlideUser: [Object],
        GlideSchedule: [Object],
        GlideElement: [Object],
        GlideDateTime: [Object],
        GlideDBFunctionBuilder: [Object],
        sn_clotho: [Object],
        GlideLocale: [Object],
        XMLNodeIterator: [Object] },
     sys_script_email:
      { GlideServletRequest: [Object],
        template: [Object],
        email_action: [Object],
        XMLNode: [Object],
        GlideScopedEvaluator: [Object],
        GlideTableHierarchy: [Object],
        GlidePluginManager: [Object],
        sn_auth: [Object],
        GlideRecord: [Object],
        sn_ws: [Object],
        GlideServletResponse: [Object],
        GlideElementDescriptor: [Object],
        GlideQueryCondition: [Object],
        GlideScriptableInputStream: [Object],
        GlideRecordSecure: [Object],
        current: [Object],
        XMLDocument2: [Object],
        event: [Object],
        GlideDuration: [Object],
        email: [Object],
        GlideAggregate: [Object],
        sn_ws_err: [Object],
        GlideSession: [Object],
        gs: [Object],
        GlideFilter: [Object],
        GlideDate: [Object],
        GlideScriptedProcessor: [Object],
        sn_ws_int: [Object],
        GlideTime: [Object],
        GlideUser: [Object],
        GlideSchedule: [Object],
        GlideElement: [Object],
        GlideDateTime: [Object],
        GlideDBFunctionBuilder: [Object],
        sn_clotho: [Object],
        GlideLocale: [Object],
        XMLNodeIterator: [Object] },
     sys_script_include:
      { GlideServletRequest: [Object],
        XMLNode: [Object],
        GlideScopedEvaluator: [Object],
        GlideTableHierarchy: [Object],
        GlidePluginManager: [Object],
        sn_auth: [Object],
        GlideRecord: [Object],
        sn_ws: [Object],
        GlideServletResponse: [Object],
        GlideElementDescriptor: [Object],
        GlideQueryCondition: [Object],
        GlideScriptableInputStream: [Object],
        GlideRecordSecure: [Object],
        XMLDocument2: [Object],
        GlideDuration: [Object],
        GlideAggregate: [Object],
        sn_ws_err: [Object],
        GlideSession: [Object],
        gs: [Object],
        GlideFilter: [Object],
        GlideDate: [Object],
        GlideScriptedProcessor: [Object],
        sn_ws_int: [Object],
        GlideTime: [Object],
        GlideUser: [Object],
        GlideSchedule: [Object],
        GlideElement: [Object],
        GlideDateTime: [Object],
        GlideDBFunctionBuilder: [Object],
        sn_clotho: [Object],
        GlideLocale: [Object],
        XMLNodeIterator: [Object] } } }
error..... ReferenceError: reponseObj is not defined
    at IncomingMessage.<anonymous> (/Users/marjacebenson/git/sn/build-apis.js:27:42)
    at IncomingMessage.emit (events.js:203:15)
    at endReadableNT (_stream_readable.js:1145:12)
    at process._tickCallback (internal/process/next_tick.js:63:19)
